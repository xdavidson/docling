{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Docling","text":"<p>Docling parses documents and exports them to the desired format with ease and speed.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\uddc2\ufe0f Reads popular document formats (PDF, DOCX, PPTX, Images, HTML, AsciiDoc, Markdown) and exports to Markdown and JSON</li> <li>\ud83d\udcd1 Advanced PDF document understanding incl. page layout, reading order &amp; table structures</li> <li>\ud83e\udde9 Unified, expressive DoclingDocument representation format</li> <li>\ud83e\udd16 Easy integration with LlamaIndex \ud83e\udd99 &amp; LangChain \ud83e\udd9c\ud83d\udd17 for powerful RAG / QA applications</li> <li>\ud83d\udd0d OCR support for scanned PDFs</li> <li>\ud83d\udcbb Simple and convenient CLI</li> </ul>"},{"location":"#coming-soon","title":"Coming soon","text":"<ul> <li>\u267e\ufe0f Equation &amp; code extraction</li> <li>\ud83d\udcdd Metadata extraction, including title, authors, references &amp; language</li> <li>\ud83e\udd9c\ud83d\udd17 Native LangChain extension</li> </ul>"},{"location":"#ibm-open-source-ai","title":"IBM \u2764\ufe0f Open Source AI","text":"<p>Docling has been brought to you by IBM.</p>"},{"location":"cli/","title":"CLI Reference","text":"<p>This page provides documentation for our command line tools.</p>"},{"location":"cli/#docling","title":"docling","text":"<p>Usage:</p> <pre><code>docling [OPTIONS] source\n</code></pre> <p>Options:</p> Name Type Description Default <code>--from</code> choice (<code>docx</code> | <code>pptx</code> | <code>html</code> | <code>image</code> | <code>pdf</code> | <code>asciidoc</code> | <code>md</code> | <code>xlsx</code>) Specify input formats to convert from. Defaults to all formats. None <code>--to</code> choice (<code>md</code> | <code>json</code> | <code>text</code> | <code>doctags</code>) Specify output formats. Defaults to Markdown. None <code>--ocr</code> / <code>--no-ocr</code> boolean If enabled, the bitmap content will be processed using OCR. <code>True</code> <code>--force-ocr</code> / <code>--no-force-ocr</code> boolean Replace any existing text with OCR generated text over the full content. <code>False</code> <code>--ocr-engine</code> choice (<code>easyocr</code> | <code>tesseract_cli</code> | <code>tesseract</code>) The OCR engine to use. <code>OcrEngine.EASYOCR</code> <code>--pdf-backend</code> choice (<code>pypdfium2</code> | <code>dlparse_v1</code> | <code>dlparse_v2</code>) The PDF backend to use. <code>PdfBackend.DLPARSE_V1</code> <code>--table-mode</code> choice (<code>fast</code> | <code>accurate</code>) The mode to use in the table structure model. <code>TableFormerMode.FAST</code> <code>--artifacts-path</code> path If provided, the location of the model artifacts. None <code>--abort-on-error</code> / <code>--no-abort-on-error</code> boolean If enabled, the bitmap content will be processed using OCR. <code>False</code> <code>--output</code> path Output directory where results are saved. <code>.</code> <code>--verbose</code>, <code>-v</code> integer Set the verbosity level. -v for info logging, -vv for debug logging. <code>0</code> <code>--version</code> boolean Show version information. None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"installation/","title":"Installation","text":"<p>To use Docling, simply install <code>docling</code> from your Python package manager, e.g. pip: <pre><code>pip install docling\n</code></pre></p> <p>Works on macOS, Linux, and Windows, with support for both x86_64 and arm64 architectures.</p> Alternative PyTorch distributions <p>The Docling models depend on the PyTorch library. Depending on your architecture, you might want to use a different distribution of <code>torch</code>. For example, you might want support for different accelerator or for a cpu-only version. All the different ways for installing <code>torch</code> are listed on their website https://pytorch.org/.</p> <p>One common situation is the installation on Linux systems with cpu-only support. In this case, we suggest the installation of Docling with the following options</p> <pre><code># Example for installing on the Linux cpu-only version\npip install docling --extra-index-url https://download.pytorch.org/whl/cpu\n</code></pre> Alternative OCR engines <p>Docling supports multiple OCR engines for processing scanned documents. The current version provides the following engines.</p> Engine Installation Usage EasyOCR Default in Docling or via <code>pip install easyocr</code>. <code>EasyOcrOptions</code> Tesseract System dependency. See description for Tesseract and Tesserocr below. <code>TesseractOcrOptions</code> Tesseract CLI System dependency. See description below. <code>TesseractCliOcrOptions</code> <p>The Docling <code>DocumentConverter</code> allows to choose the OCR engine with the <code>ocr_options</code> settings. For example</p> <pre><code>from docling.datamodel.base_models import ConversionStatus, PipelineOptions\nfrom docling.datamodel.pipeline_options import PipelineOptions, EasyOcrOptions, TesseractOcrOptions\nfrom docling.document_converter import DocumentConverter\n\npipeline_options = PipelineOptions()\npipeline_options.do_ocr = True\npipeline_options.ocr_options = TesseractOcrOptions()  # Use Tesseract\n\ndoc_converter = DocumentConverter(\n    pipeline_options=pipeline_options,\n)\n</code></pre> <p>Tesseract installation</p> <p>Tesseract is a popular OCR engine which is available on most operating systems. For using this engine with Docling, Tesseract must be installed on your system, using the packaging tool of your choice. Below we provide example commands. After installing Tesseract you are expected to provide the path to its language files using the <code>TESSDATA_PREFIX</code> environment variable (note that it must terminate with a slash <code>/</code>).</p> macOS (via Homebrew)Debian-basedRHEL <pre><code>brew install tesseract leptonica pkg-config\nTESSDATA_PREFIX=/opt/homebrew/share/tessdata/\necho \"Set TESSDATA_PREFIX=${TESSDATA_PREFIX}\"\n</code></pre> <pre><code>apt-get install tesseract-ocr tesseract-ocr-eng libtesseract-dev libleptonica-dev pkg-config\nTESSDATA_PREFIX=$(dpkg -L tesseract-ocr-eng | grep tessdata$)\necho \"Set TESSDATA_PREFIX=${TESSDATA_PREFIX}\"\n</code></pre> <pre><code>dnf install tesseract tesseract-devel tesseract-langpack-eng leptonica-devel\nTESSDATA_PREFIX=/usr/share/tesseract/tessdata/\necho \"Set TESSDATA_PREFIX=${TESSDATA_PREFIX}\"\n</code></pre> <p>Linking to Tesseract The most efficient usage of the Tesseract library is via linking. Docling is using the Tesserocr package for this.</p> <p>If you get into installation issues of Tesserocr, we suggest using the following installation options:</p> <pre><code>pip uninstall tesserocr\npip install --no-binary :all: tesserocr\n</code></pre>"},{"location":"installation/#development-setup","title":"Development setup","text":"<p>To develop Docling features, bugfixes etc., install as follows from your local clone's root dir:</p> <pre><code>poetry install --all-extras\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#conversion","title":"Conversion","text":""},{"location":"usage/#convert-a-single-document","title":"Convert a single document","text":"<p>To convert individual PDF documents, use <code>convert()</code>, for example:</p> <pre><code>from docling.document_converter import DocumentConverter\n\nsource = \"https://arxiv.org/pdf/2408.09869\"  # PDF path or URL\nconverter = DocumentConverter()\nresult = converter.convert(source)\nprint(result.document.export_to_markdown())  # output: \"### Docling Technical Report[...]\"\n</code></pre>"},{"location":"usage/#cli","title":"CLI","text":"<p>You can also use Docling directly from your command line to convert individual files \u2014be it local or by URL\u2014 or whole directories.</p> <p>A simple example would look like this: <pre><code>docling https://arxiv.org/pdf/2206.01062\n</code></pre></p> <p>To see all available options (export formats etc.) run <code>docling --help</code>. More details in the CLI reference page.</p>"},{"location":"usage/#advanced-options","title":"Advanced options","text":""},{"location":"usage/#adjust-pipeline-features","title":"Adjust pipeline features","text":"<p>The example file custom_convert.py contains multiple ways one can adjust the conversion pipeline and features.</p>"},{"location":"usage/#control-pdf-table-extraction-options","title":"Control PDF table extraction options","text":"<p>You can control if table structure recognition should map the recognized structure back to PDF cells (default) or use text cells from the structure prediction itself. This can improve output quality if you find that multiple columns in extracted tables are erroneously merged into one.</p> <pre><code>from docling.datamodel.base_models import InputFormat\nfrom docling.document_converter import DocumentConverter, PdfFormatOption\nfrom docling.datamodel.pipeline_options import PdfPipelineOptions\n\npipeline_options = PdfPipelineOptions(do_table_structure=True)\npipeline_options.table_structure_options.do_cell_matching = False  # uses text cells predicted from table structure model\n\ndoc_converter = DocumentConverter(\n    format_options={\n        InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)\n    }\n)\n</code></pre> <p>Since docling 1.16.0: You can control which TableFormer mode you want to use. Choose between <code>TableFormerMode.FAST</code> (default) and <code>TableFormerMode.ACCURATE</code> (better, but slower) to receive better quality with difficult table structures.</p> <pre><code>from docling.datamodel.base_models import InputFormat\nfrom docling.document_converter import DocumentConverter, PdfFormatOption\nfrom docling.datamodel.pipeline_options import PdfPipelineOptions, TableFormerMode\n\npipeline_options = PdfPipelineOptions(do_table_structure=True)\npipeline_options.table_structure_options.mode = TableFormerMode.ACCURATE  # use more accurate TableFormer model\n\ndoc_converter = DocumentConverter(\n    format_options={\n        InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)\n    }\n)\n</code></pre>"},{"location":"usage/#provide-specific-artifacts-path","title":"Provide specific artifacts path","text":"<p>By default, artifacts such as models are downloaded automatically upon first usage. If you would prefer to use a local path where the artifacts have been explicitly prefetched, you can do that as follows:</p> <pre><code>from docling.datamodel.base_models import InputFormat\nfrom docling.datamodel.pipeline_options import PdfPipelineOptions\nfrom docling.document_converter import DocumentConverter, PdfFormatOption\nfrom docling.pipeline.standard_pdf_pipeline import StandardPdfPipeline\n\n# # to explicitly prefetch:\n# artifacts_path = StandardPdfPipeline.download_models_hf()\n\nartifacts_path = \"/local/path/to/artifacts\"\n\npipeline_options = PdfPipelineOptions(artifacts_path=artifacts_path)\ndoc_converter = DocumentConverter(\n    format_options={\n        InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)\n    }\n)\n</code></pre>"},{"location":"usage/#impose-limits-on-the-document-size","title":"Impose limits on the document size","text":"<p>You can limit the file size and number of pages which should be allowed to process per document:</p> <pre><code>from pathlib import Path\nfrom docling.document_converter import DocumentConverter\n\nsource = \"https://arxiv.org/pdf/2408.09869\"\nconverter = DocumentConverter()\nresult = converter.convert(source, max_num_pages=100, max_file_size=20971520)\n</code></pre>"},{"location":"usage/#convert-from-binary-pdf-streams","title":"Convert from binary PDF streams","text":"<p>You can convert PDFs from a binary stream instead of from the filesystem as follows:</p> <pre><code>from io import BytesIO\nfrom docling.datamodel.base_models import DocumentStream\nfrom docling.document_converter import DocumentConverter\n\nbuf = BytesIO(your_binary_stream)\nsource = DocumentStream(name=\"my_doc.pdf\", stream=buf)\nconverter = DocumentConverter()\nresult = converter.convert(source)\n</code></pre>"},{"location":"usage/#limit-resource-usage","title":"Limit resource usage","text":"<p>You can limit the CPU threads used by Docling by setting the environment variable <code>OMP_NUM_THREADS</code> accordingly. The default setting is using 4 CPU threads.</p>"},{"location":"usage/#chunking","title":"Chunking","text":"<p>You can perform a hierarchy-aware chunking of a Docling document as follows:</p> <pre><code>from docling.document_converter import DocumentConverter\nfrom docling_core.transforms.chunker import HierarchicalChunker\n\nconv_res = DocumentConverter().convert(\"https://arxiv.org/pdf/2206.01062\")\ndoc = conv_res.document\nchunks = list(HierarchicalChunker().chunk(doc))\n\nprint(chunks[30])\n# {\n#   \"text\": \"Lately, new types of ML models for document-layout analysis have emerged [...]\",\n#   \"meta\": {\n#     \"doc_items\": [{\n#       \"self_ref\": \"#/texts/40\",\n#       \"label\": \"text\",\n#       \"prov\": [{\n#         \"page_no\": 2,\n#         \"bbox\": {\"l\": 317.06, \"t\": 325.81, \"r\": 559.18, \"b\": 239.97, ...},\n#       }]\n#     }],\n#     \"headings\": [\"2 RELATED WORK\"],\n#   }\n# }\n</code></pre>"},{"location":"v2/","title":"Docling v2","text":""},{"location":"v2/#whats-new","title":"What's new","text":"<p>Docling v2 introduces several new features:</p> <ul> <li>Understands and converts PDF, MS Word, MS Powerpoint, HTML and several image formats</li> <li>Produces a new, universal document representation which can encapsulate document hierarchy</li> <li>Comes with a fresh new API and CLI</li> </ul>"},{"location":"v2/#changes-in-docling-v2","title":"Changes in Docling v2","text":""},{"location":"v2/#cli","title":"CLI","text":"<p>We updated the command line syntax of Docling v2 to support many formats. Examples are seen below. <pre><code># Convert a single file to Markdown (default)\ndocling myfile.pdf\n\n# Convert a single file to Markdown and JSON, without OCR\ndocling myfile.pdf --to json --to md --no-ocr\n\n# Convert PDF files in input directory to Markdown (default)\ndocling ./input/dir --from pdf\n\n# Convert PDF and Word files in input directory to Markdown and JSON\ndocling ./input/dir --from pdf --from docx --to md --to json --output ./scratch\n\n# Convert all supported files in input directory to Markdown, but abort on first error\ndocling ./input/dir --output ./scratch --abort-on-error\n</code></pre></p> <p>Notable changes from Docling v1:</p> <ul> <li>The standalone switches for different export formats are removed, and replaced with <code>--from</code> and <code>--to</code> arguments, to define input and output formats respectively.</li> <li>The new <code>--abort-on-error</code> will abort any batch conversion as soon an error is encountered</li> <li>The <code>--backend</code> option for PDFs was removed</li> </ul>"},{"location":"v2/#setting-up-a-documentconverter","title":"Setting up a <code>DocumentConverter</code>","text":"<p>To accomodate many input formats, we changed the way you need to set up your <code>DocumentConverter</code> object. You can now define a list of allowed formats on the <code>DocumentConverter</code> initialization, and specify custom options per-format if desired. By default, all supported formats are allowed. If you don't provide <code>format_options</code>, defaults will be used for all <code>allowed_formats</code>.</p> <p>Format options can include the pipeline class to use, the options to provide to the pipeline, and the document backend. They are provided as format-specific types, such as <code>PdfFormatOption</code> or <code>WordFormatOption</code>, as seen below.</p> <pre><code>from docling.document_converter import DocumentConverter\nfrom docling.datamodel.base_models import InputFormat\nfrom docling.document_converter import (\n    DocumentConverter,\n    PdfFormatOption,\n    WordFormatOption,\n)\nfrom docling.pipeline.simple_pipeline import SimplePipeline\nfrom docling.pipeline.standard_pdf_pipeline import StandardPdfPipeline\nfrom docling.datamodel.pipeline_options import PdfPipelineOptions\nfrom docling.backend.pypdfium2_backend import PyPdfiumDocumentBackend\n\n## Default initialization still works as before:\n# doc_converter = DocumentConverter()\n\n\n# previous `PipelineOptions` is now `PdfPipelineOptions`\npipeline_options = PdfPipelineOptions()\npipeline_options.do_ocr = False\npipeline_options.do_table_structure = True\n#...\n\n## Custom options are now defined per format.\ndoc_converter = (\n    DocumentConverter(  # all of the below is optional, has internal defaults.\n        allowed_formats=[\n            InputFormat.PDF,\n            InputFormat.IMAGE,\n            InputFormat.DOCX,\n            InputFormat.HTML,\n            InputFormat.PPTX,\n        ],  # whitelist formats, non-matching files are ignored.\n        format_options={\n            InputFormat.PDF: PdfFormatOption(\n                pipeline_options=pipeline_options, # pipeline options go here.\n                backend=PyPdfiumDocumentBackend # optional: pick an alternative backend\n            ),\n            InputFormat.DOCX: WordFormatOption(\n                pipeline_cls=SimplePipeline # default for office formats and HTML\n            ),\n        },\n    )\n)\n</code></pre> <p>Note: If you work only with defaults, all remains the same as in Docling v1.</p> <p>More options are shown in the following example units:</p> <ul> <li>run_with_formats.py</li> <li>custom_convert.py</li> </ul>"},{"location":"v2/#converting-documents","title":"Converting documents","text":"<p>We have simplified the way you can feed input to the <code>DocumentConverter</code> and renamed the conversion methods for better semantics. You can now call the conversion directly with a single file, or a list of input files, or <code>DocumentStream</code> objects, without constructing a <code>DocumentConversionInput</code> object first.</p> <ul> <li><code>DocumentConverter.convert</code> now converts a single file input (previously <code>DocumentConverter.convert_single</code>).</li> <li><code>DocumentConverter.convert_all</code> now converts many files at once (previously <code>DocumentConverter.convert</code>).</li> </ul> <p><pre><code>...\nfrom docling.datamodel.document import ConversionResult\n## Convert a single file (from URL or local path)\nconv_result: ConversionResult = doc_converter.convert(\"https://arxiv.org/pdf/2408.09869\") # previously `convert_single`\n\n## Convert several files at once:\n\ninput_files = [\n    \"tests/data/wiki_duck.html\",\n    \"tests/data/word_sample.docx\",\n    \"tests/data/lorem_ipsum.docx\",\n    \"tests/data/powerpoint_sample.pptx\",\n    \"tests/data/2305.03393v1-pg9-img.png\",\n    \"tests/data/2206.01062.pdf\",\n]\n\n# Directly pass list of files or streams to `convert_all`\nconv_results_iter = doc_converter.convert_all(input_files) # previously `convert`\n</code></pre> Through the <code>raises_on_error</code> argument, you can also control if the conversion should raise exceptions when first encountering a problem, or resiliently convert all files first and reflect errors in each file's conversion status. By default, any error is immediately raised and the conversion aborts (previously, exceptions were swallowed).</p> <pre><code>...\nconv_results_iter = doc_converter.convert_all(input_files, raises_on_error=False) # previously `convert`\n</code></pre>"},{"location":"v2/#access-document-structures","title":"Access document structures","text":"<p>We have simplified how you can access and export the converted document data, too. Our universal document representation is now available in conversion results as a <code>DoclingDocument</code> object. <code>DoclingDocument</code> provides a neat set of APIs to construct, iterate and export content in the document, as shown below.</p> <pre><code>conv_result: ConversionResult = doc_converter.convert(\"https://arxiv.org/pdf/2408.09869\") # previously `convert_single`\n\n## Inspect the converted document:\nconv_result.document.print_element_tree()\n\n## Iterate the elements in reading order, including hierachy level:\nfor item, level in conv_result.document.iterate_items:\n    if isinstance(item, TextItem):\n        print(item.text)\n    elif isinstance(item, TableItem):\n        table_df: pd.DataFrame = item.export_to_dataframe()\n        print(table_df.to_markdown())\n    elif ...:\n        #...\n</code></pre> <p>Note: While it is deprecated, you can still work with the Docling v1 document representation, it is available as: <pre><code>conv_result.legacy_document # provides the representation in previous ExportedCCSDocument type\n</code></pre></p>"},{"location":"v2/#export-into-json-markdown-doctags","title":"Export into JSON, Markdown, Doctags","text":"<p>Note: All <code>render_...</code> methods in <code>ConversionResult</code> have been removed in Docling v2, and are now available on <code>DoclingDocument</code> as:</p> <ul> <li><code>DoclingDocument.export_to_dict</code></li> <li><code>DoclingDocument.export_to_markdown</code></li> <li><code>DoclingDocument.export_to_document_tokens</code></li> </ul> <pre><code>conv_result: ConversionResult = doc_converter.convert(\"https://arxiv.org/pdf/2408.09869\") # previously `convert_single`\n\n## Export to desired format:\nprint(json.dumps(conv_res.document.export_to_dict()))\nprint(conv_res.document.export_to_markdown())\nprint(conv_res.document.export_to_document_tokens())\n</code></pre> <p>Note: While it is deprecated, you can still export Docling v1 JSON format. This is available through the same methods as on the <code>DoclingDocument</code> type: <pre><code>## Export legacy document representation to desired format, for v1 compatibility:\nprint(json.dumps(conv_res.legacy_document.export_to_dict()))\nprint(conv_res.legacy_document.export_to_markdown())\nprint(conv_res.legacy_document.export_to_document_tokens())\n</code></pre></p>"},{"location":"v2/#reload-a-doclingdocument-stored-as-json","title":"Reload a <code>DoclingDocument</code> stored as JSON","text":"<p>You can save and reload a <code>DoclingDocument</code> to disk in JSON format using the following codes:</p> <pre><code># Save to disk:\ndoc: DoclingDocument = conv_res.document # produced from conversion result...\n\nwith Path(\"./doc.json\").open(\"w\") as fp:\n    fp.write(json.dumps(doc.export_to_dict())) # use `export_to_dict` to ensure consistency\n\n# Load from disk:\nwith Path(\"./doc.json\").open(\"r\") as fp:\n    doc_dict = json.loads(fp.read())\n    doc = DoclingDocument.model_validate(doc_dict) # use standard pydantic API to populate doc\n</code></pre>"},{"location":"v2/#chunking","title":"Chunking","text":"<p>Docling v2 defines new base classes for chunking:</p> <ul> <li><code>BaseMeta</code> for chunk metadata</li> <li><code>BaseChunk</code> containing the chunk text and metadata, and</li> <li><code>BaseChunker</code> for chunkers, producing chunks out of a <code>DoclingDocument</code>.</li> </ul> <p>Additionally, it provides an updated <code>HierarchicalChunker</code> implementation, which leverages the new <code>DoclingDocument</code> and provides a new, richer chunk output format, including:</p> <ul> <li>the respective doc items for grounding</li> <li>any applicable headings for context</li> <li>any applicable captions for context</li> </ul> <p>For an example, check out Chunking usage.</p>"},{"location":"concepts/","title":"Concepts","text":"<p>Use the navigation on the left to browse some core Docling concepts.</p>"},{"location":"concepts/architecture/","title":"Architecture","text":"<p>In a nutshell, Docling's architecture is outlined in the diagram above.</p> <p>For each document format, the document converter knows which format-specific backend to employ for parsing the document and which pipeline to use for orchestrating the execution, along with any relevant options.</p> <p>Tip</p> <p>While the document converter holds a default mapping, this configuration is parametrizable, so e.g. for the PDF format, different backends and different pipeline options can be used \u2014 see Usage.</p> <p>The conversion result contains the Docling document, Docling's fundamental document representation.</p> <p>Some typical scenarios for using a Docling document include directly calling its export methods, such as for markdown, dictionary etc., or having it chunked by a chunker.</p> <p>For more details on Docling's architecture, check out the Docling Technical Report.</p> <p>Note</p> <p>The components illustrated with dashed outline indicate base classes that can be subclassed for specialized implementations.</p>"},{"location":"concepts/docling_document/","title":"Docling Document","text":"<p>With Docling v2, we introduce a unified document representation format called <code>DoclingDocument</code>. It is defined as a pydantic datatype, which can express several features common to documents, such as:</p> <ul> <li>Text, Tables, Pictures, and more</li> <li>Document hierarchy with sections and groups</li> <li>Disambiguation between main body and headers, footers (furniture)</li> <li>Layout information (i.e. bounding boxes) for all items, if available</li> <li>Provenance information</li> </ul> <p>The definition of the Pydantic types is implemented in the module <code>docling_core.types.doc</code>, more details in source code definitions.</p> <p>It also brings a set of document construction APIs to build up a <code>DoclingDocument</code> from scratch.</p>"},{"location":"concepts/docling_document/#example-document-structures","title":"Example document structures","text":"<p>To illustrate the features of the <code>DoclingDocument</code> format, in the subsections below we consider the <code>DoclingDocument</code> converted from <code>tests/data/word_sample.docx</code> and we present some side-by-side comparisons, where the left side shows snippets from the converted document serialized as YAML and the right one shows the corresponding parts of the original MS Word.</p>"},{"location":"concepts/docling_document/#basic-structure","title":"Basic structure","text":"<p>A <code>DoclingDocument</code> exposes top-level fields for the document content, organized in two categories. The first category is the content items, which are stored in these fields:</p> <ul> <li><code>texts</code>: All items that have a text representation (paragraph, section heading, equation, ...). Base class is <code>TextItem</code>.</li> <li><code>tables</code>: All tables, type <code>TableItem</code>. Can carry structure annotations.</li> <li><code>pictures</code>: All pictures, type <code>PictureItem</code>. Can carry structure annotations.</li> <li><code>key_value_items</code>: All key-value items.</li> </ul> <p>All of the above fields are lists and store items inheriting from the <code>DocItem</code> type. They can express different data structures depending on their type, and reference parents and children through JSON pointers.</p> <p>The second category is content structure, which is encapsualted in:</p> <ul> <li><code>body</code>: The root node of a tree-structure for the main document body</li> <li><code>furniture</code>: The root node of a tree-structure for all items that don't belong into the body (headers, footers, ...)</li> <li><code>groups</code>: A set of items that don't represent content, but act as containers for other content items (e.g. a list, a chapter)</li> </ul> <p>All of the above fields are only storing <code>NodeItem</code> instances, which reference children and parents through JSON pointers.</p> <p>The reading order of the document is encapsulated through the <code>body</code> tree and the order of children in each item in the tree.</p> <p>Below example shows how all items in the first page are nested below the <code>title</code> item (<code>#/texts/1</code>).</p> <p></p>"},{"location":"concepts/docling_document/#grouping","title":"Grouping","text":"<p>Below example shows how all items under the heading \"Let's swim\" (<code>#/texts/5</code>) are nested as chilrden. The children of \"Let's swim\" are both text items and groups, which contain the list elements. The group items are stored in the top-level <code>groups</code> field.</p> <p></p>"},{"location":"examples/","title":"Examples","text":"<p>Use the navigation on the left to browse through examples covering a range of possible workflows and use cases.</p>"},{"location":"examples/batch_convert/","title":"Batch conversion","text":"In\u00a0[\u00a0]: Copied! <pre>import json\nimport logging\nimport time\nfrom pathlib import Path\nfrom typing import Iterable\n</pre> import json import logging import time from pathlib import Path from typing import Iterable In\u00a0[\u00a0]: Copied! <pre>import yaml\n</pre> import yaml In\u00a0[\u00a0]: Copied! <pre>from docling.datamodel.base_models import ConversionStatus\nfrom docling.datamodel.document import ConversionResult\nfrom docling.datamodel.settings import settings\nfrom docling.document_converter import DocumentConverter\n</pre> from docling.datamodel.base_models import ConversionStatus from docling.datamodel.document import ConversionResult from docling.datamodel.settings import settings from docling.document_converter import DocumentConverter In\u00a0[\u00a0]: Copied! <pre>_log = logging.getLogger(__name__)\n</pre> _log = logging.getLogger(__name__) In\u00a0[\u00a0]: Copied! <pre>USE_V2 = True\nUSE_LEGACY = True\n</pre> USE_V2 = True USE_LEGACY = True In\u00a0[\u00a0]: Copied! <pre>def export_documents(\n    conv_results: Iterable[ConversionResult],\n    output_dir: Path,\n):\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    success_count = 0\n    failure_count = 0\n    partial_success_count = 0\n\n    for conv_res in conv_results:\n        if conv_res.status == ConversionStatus.SUCCESS:\n            success_count += 1\n            doc_filename = conv_res.input.file.stem\n\n            if USE_V2:\n                # Export Docling document format to JSON:\n                with (output_dir / f\"{doc_filename}.json\").open(\"w\") as fp:\n                    fp.write(json.dumps(conv_res.document.export_to_dict()))\n\n                # Export Docling document format to YAML:\n                with (output_dir / f\"{doc_filename}.yaml\").open(\"w\") as fp:\n                    fp.write(yaml.safe_dump(conv_res.document.export_to_dict()))\n\n                # Export Docling document format to doctags:\n                with (output_dir / f\"{doc_filename}.doctags.txt\").open(\"w\") as fp:\n                    fp.write(conv_res.document.export_to_document_tokens())\n\n                # Export Docling document format to markdown:\n                with (output_dir / f\"{doc_filename}.md\").open(\"w\") as fp:\n                    fp.write(conv_res.document.export_to_markdown())\n\n                # Export Docling document format to text:\n                with (output_dir / f\"{doc_filename}.txt\").open(\"w\") as fp:\n                    fp.write(conv_res.document.export_to_markdown(strict_text=True))\n\n            if USE_LEGACY:\n                # Export Deep Search document JSON format:\n                with (output_dir / f\"{doc_filename}.legacy.json\").open(\n                    \"w\", encoding=\"utf-8\"\n                ) as fp:\n                    fp.write(json.dumps(conv_res.legacy_document.export_to_dict()))\n\n                # Export Text format:\n                with (output_dir / f\"{doc_filename}.legacy.txt\").open(\n                    \"w\", encoding=\"utf-8\"\n                ) as fp:\n                    fp.write(\n                        conv_res.legacy_document.export_to_markdown(strict_text=True)\n                    )\n\n                # Export Markdown format:\n                with (output_dir / f\"{doc_filename}.legacy.md\").open(\n                    \"w\", encoding=\"utf-8\"\n                ) as fp:\n                    fp.write(conv_res.legacy_document.export_to_markdown())\n\n                # Export Document Tags format:\n                with (output_dir / f\"{doc_filename}.legacy.doctags.txt\").open(\n                    \"w\", encoding=\"utf-8\"\n                ) as fp:\n                    fp.write(conv_res.legacy_document.export_to_document_tokens())\n\n        elif conv_res.status == ConversionStatus.PARTIAL_SUCCESS:\n            _log.info(\n                f\"Document {conv_res.input.file} was partially converted with the following errors:\"\n            )\n            for item in conv_res.errors:\n                _log.info(f\"\\t{item.error_message}\")\n            partial_success_count += 1\n        else:\n            _log.info(f\"Document {conv_res.input.file} failed to convert.\")\n            failure_count += 1\n\n    _log.info(\n        f\"Processed {success_count + partial_success_count + failure_count} docs, \"\n        f\"of which {failure_count} failed \"\n        f\"and {partial_success_count} were partially converted.\"\n    )\n    return success_count, partial_success_count, failure_count\n</pre> def export_documents(     conv_results: Iterable[ConversionResult],     output_dir: Path, ):     output_dir.mkdir(parents=True, exist_ok=True)      success_count = 0     failure_count = 0     partial_success_count = 0      for conv_res in conv_results:         if conv_res.status == ConversionStatus.SUCCESS:             success_count += 1             doc_filename = conv_res.input.file.stem              if USE_V2:                 # Export Docling document format to JSON:                 with (output_dir / f\"{doc_filename}.json\").open(\"w\") as fp:                     fp.write(json.dumps(conv_res.document.export_to_dict()))                  # Export Docling document format to YAML:                 with (output_dir / f\"{doc_filename}.yaml\").open(\"w\") as fp:                     fp.write(yaml.safe_dump(conv_res.document.export_to_dict()))                  # Export Docling document format to doctags:                 with (output_dir / f\"{doc_filename}.doctags.txt\").open(\"w\") as fp:                     fp.write(conv_res.document.export_to_document_tokens())                  # Export Docling document format to markdown:                 with (output_dir / f\"{doc_filename}.md\").open(\"w\") as fp:                     fp.write(conv_res.document.export_to_markdown())                  # Export Docling document format to text:                 with (output_dir / f\"{doc_filename}.txt\").open(\"w\") as fp:                     fp.write(conv_res.document.export_to_markdown(strict_text=True))              if USE_LEGACY:                 # Export Deep Search document JSON format:                 with (output_dir / f\"{doc_filename}.legacy.json\").open(                     \"w\", encoding=\"utf-8\"                 ) as fp:                     fp.write(json.dumps(conv_res.legacy_document.export_to_dict()))                  # Export Text format:                 with (output_dir / f\"{doc_filename}.legacy.txt\").open(                     \"w\", encoding=\"utf-8\"                 ) as fp:                     fp.write(                         conv_res.legacy_document.export_to_markdown(strict_text=True)                     )                  # Export Markdown format:                 with (output_dir / f\"{doc_filename}.legacy.md\").open(                     \"w\", encoding=\"utf-8\"                 ) as fp:                     fp.write(conv_res.legacy_document.export_to_markdown())                  # Export Document Tags format:                 with (output_dir / f\"{doc_filename}.legacy.doctags.txt\").open(                     \"w\", encoding=\"utf-8\"                 ) as fp:                     fp.write(conv_res.legacy_document.export_to_document_tokens())          elif conv_res.status == ConversionStatus.PARTIAL_SUCCESS:             _log.info(                 f\"Document {conv_res.input.file} was partially converted with the following errors:\"             )             for item in conv_res.errors:                 _log.info(f\"\\t{item.error_message}\")             partial_success_count += 1         else:             _log.info(f\"Document {conv_res.input.file} failed to convert.\")             failure_count += 1      _log.info(         f\"Processed {success_count + partial_success_count + failure_count} docs, \"         f\"of which {failure_count} failed \"         f\"and {partial_success_count} were partially converted.\"     )     return success_count, partial_success_count, failure_count In\u00a0[\u00a0]: Copied! <pre>def main():\n    logging.basicConfig(level=logging.INFO)\n\n    input_doc_paths = [\n        Path(\"./tests/data/2206.01062.pdf\"),\n        Path(\"./tests/data/2203.01017v2.pdf\"),\n        Path(\"./tests/data/2305.03393v1.pdf\"),\n        Path(\"./tests/data/redp5110_sampled.pdf\"),\n    ]\n\n    # buf = BytesIO(Path(\"./test/data/2206.01062.pdf\").open(\"rb\").read())\n    # docs = [DocumentStream(name=\"my_doc.pdf\", stream=buf)]\n    # input = DocumentConversionInput.from_streams(docs)\n\n    # # Turn on inline debug visualizations:\n    # settings.debug.visualize_layout = True\n    # settings.debug.visualize_ocr = True\n    # settings.debug.visualize_tables = True\n    # settings.debug.visualize_cells = True\n\n    doc_converter = DocumentConverter()\n\n    start_time = time.time()\n\n    conv_results = doc_converter.convert_all(\n        input_doc_paths,\n        raises_on_error=False,  # to let conversion run through all and examine results at the end\n    )\n    success_count, partial_success_count, failure_count = export_documents(\n        conv_results, output_dir=Path(\"scratch\")\n    )\n\n    end_time = time.time() - start_time\n\n    _log.info(f\"Document conversion complete in {end_time:.2f} seconds.\")\n\n    if failure_count &gt; 0:\n        raise RuntimeError(\n            f\"The example failed converting {failure_count} on {len(input_doc_paths)}.\"\n        )\n</pre> def main():     logging.basicConfig(level=logging.INFO)      input_doc_paths = [         Path(\"./tests/data/2206.01062.pdf\"),         Path(\"./tests/data/2203.01017v2.pdf\"),         Path(\"./tests/data/2305.03393v1.pdf\"),         Path(\"./tests/data/redp5110_sampled.pdf\"),     ]      # buf = BytesIO(Path(\"./test/data/2206.01062.pdf\").open(\"rb\").read())     # docs = [DocumentStream(name=\"my_doc.pdf\", stream=buf)]     # input = DocumentConversionInput.from_streams(docs)      # # Turn on inline debug visualizations:     # settings.debug.visualize_layout = True     # settings.debug.visualize_ocr = True     # settings.debug.visualize_tables = True     # settings.debug.visualize_cells = True      doc_converter = DocumentConverter()      start_time = time.time()      conv_results = doc_converter.convert_all(         input_doc_paths,         raises_on_error=False,  # to let conversion run through all and examine results at the end     )     success_count, partial_success_count, failure_count = export_documents(         conv_results, output_dir=Path(\"scratch\")     )      end_time = time.time() - start_time      _log.info(f\"Document conversion complete in {end_time:.2f} seconds.\")      if failure_count &gt; 0:         raise RuntimeError(             f\"The example failed converting {failure_count} on {len(input_doc_paths)}.\"         ) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"},{"location":"examples/custom_convert/","title":"Custom conversion","text":"In\u00a0[\u00a0]: Copied! <pre>import json\nimport logging\nimport time\nfrom pathlib import Path\n</pre> import json import logging import time from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>from docling.backend.pypdfium2_backend import PyPdfiumDocumentBackend\nfrom docling.datamodel.base_models import InputFormat\nfrom docling.datamodel.pipeline_options import PdfPipelineOptions\nfrom docling.document_converter import DocumentConverter, PdfFormatOption\nfrom docling.models.tesseract_ocr_cli_model import TesseractCliOcrOptions\nfrom docling.models.tesseract_ocr_model import TesseractOcrOptions\n</pre> from docling.backend.pypdfium2_backend import PyPdfiumDocumentBackend from docling.datamodel.base_models import InputFormat from docling.datamodel.pipeline_options import PdfPipelineOptions from docling.document_converter import DocumentConverter, PdfFormatOption from docling.models.tesseract_ocr_cli_model import TesseractCliOcrOptions from docling.models.tesseract_ocr_model import TesseractOcrOptions In\u00a0[\u00a0]: Copied! <pre>_log = logging.getLogger(__name__)\n</pre> _log = logging.getLogger(__name__) In\u00a0[\u00a0]: Copied! <pre>def main():\n    logging.basicConfig(level=logging.INFO)\n\n    input_doc_path = Path(\"./tests/data/2206.01062.pdf\")\n\n    ###########################################################################\n\n    # The following sections contain a combination of PipelineOptions\n    # and PDF Backends for various configurations.\n    # Uncomment one section at the time to see the differences in the output.\n\n    # PyPdfium without EasyOCR\n    # --------------------\n    # pipeline_options = PdfPipelineOptions()\n    # pipeline_options.do_ocr = False\n    # pipeline_options.do_table_structure = True\n    # pipeline_options.table_structure_options.do_cell_matching = False\n\n    # doc_converter = DocumentConverter(\n    #     format_options={\n    #         InputFormat.PDF: PdfFormatOption(\n    #             pipeline_options=pipeline_options, backend=PyPdfiumDocumentBackend\n    #         )\n    #     }\n    # )\n\n    # PyPdfium with EasyOCR\n    # -----------------\n    # pipeline_options = PdfPipelineOptions()\n    # pipeline_options.do_ocr = True\n    # pipeline_options.do_table_structure = True\n    # pipeline_options.table_structure_options.do_cell_matching = True\n\n    # doc_converter = DocumentConverter(\n    #     format_options={\n    #         InputFormat.PDF: PdfFormatOption(\n    #             pipeline_options=pipeline_options, backend=PyPdfiumDocumentBackend\n    #         )\n    #     }\n    # )\n\n    # Docling Parse without EasyOCR\n    # -------------------------\n    # pipeline_options = PdfPipelineOptions()\n    # pipeline_options.do_ocr = False\n    # pipeline_options.do_table_structure = True\n    # pipeline_options.table_structure_options.do_cell_matching = True\n\n    # doc_converter = DocumentConverter(\n    #     format_options={\n    #         InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)\n    #     }\n    # )\n\n    # Docling Parse with EasyOCR\n    # ----------------------\n    pipeline_options = PdfPipelineOptions()\n    pipeline_options.do_ocr = True\n    pipeline_options.do_table_structure = True\n    pipeline_options.table_structure_options.do_cell_matching = True\n\n    doc_converter = DocumentConverter(\n        format_options={\n            InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)\n        }\n    )\n\n    # Docling Parse with EasyOCR (CPU only)\n    # ----------------------\n    # pipeline_options = PdfPipelineOptions()\n    # pipeline_options.do_ocr = True\n    # pipeline_options.ocr_options.use_gpu = False  # &lt;-- set this.\n    # pipeline_options.do_table_structure = True\n    # pipeline_options.table_structure_options.do_cell_matching = True\n\n    # doc_converter = DocumentConverter(\n    #     format_options={\n    #         InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)\n    #     }\n    # )\n\n    # Docling Parse with Tesseract\n    # ----------------------\n    # pipeline_options = PdfPipelineOptions()\n    # pipeline_options.do_ocr = True\n    # pipeline_options.do_table_structure = True\n    # pipeline_options.table_structure_options.do_cell_matching = True\n    # pipeline_options.ocr_options = TesseractOcrOptions()\n\n    # doc_converter = DocumentConverter(\n    #     format_options={\n    #         InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)\n    #     }\n    # )\n\n    # Docling Parse with Tesseract CLI\n    # ----------------------\n    # pipeline_options = PdfPipelineOptions()\n    # pipeline_options.do_ocr = True\n    # pipeline_options.do_table_structure = True\n    # pipeline_options.table_structure_options.do_cell_matching = True\n    # pipeline_options.ocr_options = TesseractCliOcrOptions()\n\n    # doc_converter = DocumentConverter(\n    #     format_options={\n    #         InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)\n    #     }\n    # )\n\n    ###########################################################################\n\n    start_time = time.time()\n    conv_result = doc_converter.convert(input_doc_path)\n    end_time = time.time() - start_time\n\n    _log.info(f\"Document converted in {end_time:.2f} seconds.\")\n\n    ## Export results\n    output_dir = Path(\"scratch\")\n    output_dir.mkdir(parents=True, exist_ok=True)\n    doc_filename = conv_result.input.file.stem\n\n    # Export Deep Search document JSON format:\n    with (output_dir / f\"{doc_filename}.json\").open(\"w\", encoding=\"utf-8\") as fp:\n        fp.write(json.dumps(conv_result.document.export_to_dict()))\n\n    # Export Text format:\n    with (output_dir / f\"{doc_filename}.txt\").open(\"w\", encoding=\"utf-8\") as fp:\n        fp.write(conv_result.document.export_to_text())\n\n    # Export Markdown format:\n    with (output_dir / f\"{doc_filename}.md\").open(\"w\", encoding=\"utf-8\") as fp:\n        fp.write(conv_result.document.export_to_markdown())\n\n    # Export Document Tags format:\n    with (output_dir / f\"{doc_filename}.doctags\").open(\"w\", encoding=\"utf-8\") as fp:\n        fp.write(conv_result.document.export_to_document_tokens())\n</pre> def main():     logging.basicConfig(level=logging.INFO)      input_doc_path = Path(\"./tests/data/2206.01062.pdf\")      ###########################################################################      # The following sections contain a combination of PipelineOptions     # and PDF Backends for various configurations.     # Uncomment one section at the time to see the differences in the output.      # PyPdfium without EasyOCR     # --------------------     # pipeline_options = PdfPipelineOptions()     # pipeline_options.do_ocr = False     # pipeline_options.do_table_structure = True     # pipeline_options.table_structure_options.do_cell_matching = False      # doc_converter = DocumentConverter(     #     format_options={     #         InputFormat.PDF: PdfFormatOption(     #             pipeline_options=pipeline_options, backend=PyPdfiumDocumentBackend     #         )     #     }     # )      # PyPdfium with EasyOCR     # -----------------     # pipeline_options = PdfPipelineOptions()     # pipeline_options.do_ocr = True     # pipeline_options.do_table_structure = True     # pipeline_options.table_structure_options.do_cell_matching = True      # doc_converter = DocumentConverter(     #     format_options={     #         InputFormat.PDF: PdfFormatOption(     #             pipeline_options=pipeline_options, backend=PyPdfiumDocumentBackend     #         )     #     }     # )      # Docling Parse without EasyOCR     # -------------------------     # pipeline_options = PdfPipelineOptions()     # pipeline_options.do_ocr = False     # pipeline_options.do_table_structure = True     # pipeline_options.table_structure_options.do_cell_matching = True      # doc_converter = DocumentConverter(     #     format_options={     #         InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)     #     }     # )      # Docling Parse with EasyOCR     # ----------------------     pipeline_options = PdfPipelineOptions()     pipeline_options.do_ocr = True     pipeline_options.do_table_structure = True     pipeline_options.table_structure_options.do_cell_matching = True      doc_converter = DocumentConverter(         format_options={             InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)         }     )      # Docling Parse with EasyOCR (CPU only)     # ----------------------     # pipeline_options = PdfPipelineOptions()     # pipeline_options.do_ocr = True     # pipeline_options.ocr_options.use_gpu = False  # &lt;-- set this.     # pipeline_options.do_table_structure = True     # pipeline_options.table_structure_options.do_cell_matching = True      # doc_converter = DocumentConverter(     #     format_options={     #         InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)     #     }     # )      # Docling Parse with Tesseract     # ----------------------     # pipeline_options = PdfPipelineOptions()     # pipeline_options.do_ocr = True     # pipeline_options.do_table_structure = True     # pipeline_options.table_structure_options.do_cell_matching = True     # pipeline_options.ocr_options = TesseractOcrOptions()      # doc_converter = DocumentConverter(     #     format_options={     #         InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)     #     }     # )      # Docling Parse with Tesseract CLI     # ----------------------     # pipeline_options = PdfPipelineOptions()     # pipeline_options.do_ocr = True     # pipeline_options.do_table_structure = True     # pipeline_options.table_structure_options.do_cell_matching = True     # pipeline_options.ocr_options = TesseractCliOcrOptions()      # doc_converter = DocumentConverter(     #     format_options={     #         InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)     #     }     # )      ###########################################################################      start_time = time.time()     conv_result = doc_converter.convert(input_doc_path)     end_time = time.time() - start_time      _log.info(f\"Document converted in {end_time:.2f} seconds.\")      ## Export results     output_dir = Path(\"scratch\")     output_dir.mkdir(parents=True, exist_ok=True)     doc_filename = conv_result.input.file.stem      # Export Deep Search document JSON format:     with (output_dir / f\"{doc_filename}.json\").open(\"w\", encoding=\"utf-8\") as fp:         fp.write(json.dumps(conv_result.document.export_to_dict()))      # Export Text format:     with (output_dir / f\"{doc_filename}.txt\").open(\"w\", encoding=\"utf-8\") as fp:         fp.write(conv_result.document.export_to_text())      # Export Markdown format:     with (output_dir / f\"{doc_filename}.md\").open(\"w\", encoding=\"utf-8\") as fp:         fp.write(conv_result.document.export_to_markdown())      # Export Document Tags format:     with (output_dir / f\"{doc_filename}.doctags\").open(\"w\", encoding=\"utf-8\") as fp:         fp.write(conv_result.document.export_to_document_tokens()) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"},{"location":"examples/develop_picture_enrichment/","title":"Figure enrichment","text":"In\u00a0[\u00a0]: Copied! <pre>import logging\nfrom pathlib import Path\nfrom typing import Any, Iterable\n</pre> import logging from pathlib import Path from typing import Any, Iterable In\u00a0[\u00a0]: Copied! <pre>from docling_core.types.doc import (\n    DoclingDocument,\n    NodeItem,\n    PictureClassificationClass,\n    PictureClassificationData,\n    PictureItem,\n)\n</pre> from docling_core.types.doc import (     DoclingDocument,     NodeItem,     PictureClassificationClass,     PictureClassificationData,     PictureItem, ) In\u00a0[\u00a0]: Copied! <pre>from docling.datamodel.base_models import InputFormat\nfrom docling.datamodel.pipeline_options import PdfPipelineOptions\nfrom docling.document_converter import DocumentConverter, PdfFormatOption\nfrom docling.models.base_model import BaseEnrichmentModel\nfrom docling.pipeline.standard_pdf_pipeline import StandardPdfPipeline\n</pre> from docling.datamodel.base_models import InputFormat from docling.datamodel.pipeline_options import PdfPipelineOptions from docling.document_converter import DocumentConverter, PdfFormatOption from docling.models.base_model import BaseEnrichmentModel from docling.pipeline.standard_pdf_pipeline import StandardPdfPipeline In\u00a0[\u00a0]: Copied! <pre>class ExamplePictureClassifierPipelineOptions(PdfPipelineOptions):\n    do_picture_classifer: bool = True\n</pre> class ExamplePictureClassifierPipelineOptions(PdfPipelineOptions):     do_picture_classifer: bool = True In\u00a0[\u00a0]: Copied! <pre>class ExamplePictureClassifierEnrichmentModel(BaseEnrichmentModel):\n\n    def __init__(self, enabled: bool):\n        self.enabled = enabled\n\n    def is_processable(self, doc: DoclingDocument, element: NodeItem) -&gt; bool:\n        return self.enabled and isinstance(element, PictureItem)\n\n    def __call__(\n        self, doc: DoclingDocument, element_batch: Iterable[NodeItem]\n    ) -&gt; Iterable[Any]:\n        if not self.enabled:\n            return\n\n        for element in element_batch:\n            assert isinstance(element, PictureItem)\n\n            # uncomment this to interactively visualize the image\n            # element.image.pil_image.show()\n\n            element.annotations.append(\n                PictureClassificationData(\n                    provenance=\"example_classifier-0.0.1\",\n                    predicted_classes=[\n                        PictureClassificationClass(class_name=\"dummy\", confidence=0.42)\n                    ],\n                )\n            )\n\n            yield element\n</pre> class ExamplePictureClassifierEnrichmentModel(BaseEnrichmentModel):      def __init__(self, enabled: bool):         self.enabled = enabled      def is_processable(self, doc: DoclingDocument, element: NodeItem) -&gt; bool:         return self.enabled and isinstance(element, PictureItem)      def __call__(         self, doc: DoclingDocument, element_batch: Iterable[NodeItem]     ) -&gt; Iterable[Any]:         if not self.enabled:             return          for element in element_batch:             assert isinstance(element, PictureItem)              # uncomment this to interactively visualize the image             # element.image.pil_image.show()              element.annotations.append(                 PictureClassificationData(                     provenance=\"example_classifier-0.0.1\",                     predicted_classes=[                         PictureClassificationClass(class_name=\"dummy\", confidence=0.42)                     ],                 )             )              yield element In\u00a0[\u00a0]: Copied! <pre>class ExamplePictureClassifierPipeline(StandardPdfPipeline):\n\n    def __init__(self, pipeline_options: ExamplePictureClassifierPipelineOptions):\n        super().__init__(pipeline_options)\n        self.pipeline_options: ExamplePictureClassifierPipeline\n\n        self.enrichment_pipe = [\n            ExamplePictureClassifierEnrichmentModel(\n                enabled=pipeline_options.do_picture_classifer\n            )\n        ]\n\n    @classmethod\n    def get_default_options(cls) -&gt; ExamplePictureClassifierPipelineOptions:\n        return ExamplePictureClassifierPipelineOptions()\n</pre> class ExamplePictureClassifierPipeline(StandardPdfPipeline):      def __init__(self, pipeline_options: ExamplePictureClassifierPipelineOptions):         super().__init__(pipeline_options)         self.pipeline_options: ExamplePictureClassifierPipeline          self.enrichment_pipe = [             ExamplePictureClassifierEnrichmentModel(                 enabled=pipeline_options.do_picture_classifer             )         ]      @classmethod     def get_default_options(cls) -&gt; ExamplePictureClassifierPipelineOptions:         return ExamplePictureClassifierPipelineOptions() In\u00a0[\u00a0]: Copied! <pre>def main():\n    logging.basicConfig(level=logging.INFO)\n\n    input_doc_path = Path(\"./tests/data/2206.01062.pdf\")\n\n    pipeline_options = ExamplePictureClassifierPipelineOptions()\n    pipeline_options.images_scale = 2.0\n    pipeline_options.generate_picture_images = True\n\n    doc_converter = DocumentConverter(\n        format_options={\n            InputFormat.PDF: PdfFormatOption(\n                pipeline_cls=ExamplePictureClassifierPipeline,\n                pipeline_options=pipeline_options,\n            )\n        }\n    )\n    result = doc_converter.convert(input_doc_path)\n\n    for element, _level in result.document.iterate_items():\n        if isinstance(element, PictureItem):\n            print(\n                f\"The model populated the `data` portion of picture {element.self_ref}:\\n{element.annotations}\"\n            )\n</pre> def main():     logging.basicConfig(level=logging.INFO)      input_doc_path = Path(\"./tests/data/2206.01062.pdf\")      pipeline_options = ExamplePictureClassifierPipelineOptions()     pipeline_options.images_scale = 2.0     pipeline_options.generate_picture_images = True      doc_converter = DocumentConverter(         format_options={             InputFormat.PDF: PdfFormatOption(                 pipeline_cls=ExamplePictureClassifierPipeline,                 pipeline_options=pipeline_options,             )         }     )     result = doc_converter.convert(input_doc_path)      for element, _level in result.document.iterate_items():         if isinstance(element, PictureItem):             print(                 f\"The model populated the `data` portion of picture {element.self_ref}:\\n{element.annotations}\"             ) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"},{"location":"examples/export_figures/","title":"Figure export","text":"In\u00a0[\u00a0]: Copied! <pre>import logging\nimport time\nfrom pathlib import Path\n</pre> import logging import time from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>from docling_core.types.doc import ImageRefMode, PictureItem, TableItem\n</pre> from docling_core.types.doc import ImageRefMode, PictureItem, TableItem In\u00a0[\u00a0]: Copied! <pre>from docling.datamodel.base_models import FigureElement, InputFormat, Table\nfrom docling.datamodel.pipeline_options import PdfPipelineOptions\nfrom docling.document_converter import DocumentConverter, PdfFormatOption\n</pre> from docling.datamodel.base_models import FigureElement, InputFormat, Table from docling.datamodel.pipeline_options import PdfPipelineOptions from docling.document_converter import DocumentConverter, PdfFormatOption In\u00a0[\u00a0]: Copied! <pre>_log = logging.getLogger(__name__)\n</pre> _log = logging.getLogger(__name__) In\u00a0[\u00a0]: Copied! <pre>IMAGE_RESOLUTION_SCALE = 2.0\n</pre> IMAGE_RESOLUTION_SCALE = 2.0 In\u00a0[\u00a0]: Copied! <pre>def main():\n    logging.basicConfig(level=logging.INFO)\n\n    input_doc_path = Path(\"./tests/data/2206.01062.pdf\")\n    output_dir = Path(\"scratch\")\n\n    # Important: For operating with page images, we must keep them, otherwise the DocumentConverter\n    # will destroy them for cleaning up memory.\n    # This is done by setting PdfPipelineOptions.images_scale, which also defines the scale of images.\n    # scale=1 correspond of a standard 72 DPI image\n    # The PdfPipelineOptions.generate_* are the selectors for the document elements which will be enriched\n    # with the image field\n    pipeline_options = PdfPipelineOptions()\n    pipeline_options.images_scale = IMAGE_RESOLUTION_SCALE\n    pipeline_options.generate_page_images = True\n    pipeline_options.generate_table_images = True\n    pipeline_options.generate_picture_images = True\n\n    doc_converter = DocumentConverter(\n        format_options={\n            InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)\n        }\n    )\n\n    start_time = time.time()\n\n    conv_res = doc_converter.convert(input_doc_path)\n\n    output_dir.mkdir(parents=True, exist_ok=True)\n    doc_filename = conv_res.input.file.stem\n\n    # Save page images\n    for page_no, page in conv_res.document.pages.items():\n        page_no = page.page_no\n        page_image_filename = output_dir / f\"{doc_filename}-{page_no}.png\"\n        with page_image_filename.open(\"wb\") as fp:\n            page.image.pil_image.save(fp, format=\"PNG\")\n\n    # Save images of figures and tables\n    table_counter = 0\n    picture_counter = 0\n    for element, _level in conv_res.document.iterate_items():\n        if isinstance(element, TableItem):\n            table_counter += 1\n            element_image_filename = (\n                output_dir / f\"{doc_filename}-table-{table_counter}.png\"\n            )\n            with element_image_filename.open(\"wb\") as fp:\n                element.image.pil_image.save(fp, \"PNG\")\n\n        if isinstance(element, PictureItem):\n            picture_counter += 1\n            element_image_filename = (\n                output_dir / f\"{doc_filename}-picture-{picture_counter}.png\"\n            )\n            with element_image_filename.open(\"wb\") as fp:\n                element.image.pil_image.save(fp, \"PNG\")\n\n    # Save markdown with embedded pictures\n    content_md = conv_res.document.export_to_markdown(image_mode=ImageRefMode.EMBEDDED)\n    md_filename = output_dir / f\"{doc_filename}-with-images.md\"\n    with md_filename.open(\"w\") as fp:\n        fp.write(content_md)\n\n    end_time = time.time() - start_time\n\n    _log.info(f\"Document converted and figures exported in {end_time:.2f} seconds.\")\n</pre> def main():     logging.basicConfig(level=logging.INFO)      input_doc_path = Path(\"./tests/data/2206.01062.pdf\")     output_dir = Path(\"scratch\")      # Important: For operating with page images, we must keep them, otherwise the DocumentConverter     # will destroy them for cleaning up memory.     # This is done by setting PdfPipelineOptions.images_scale, which also defines the scale of images.     # scale=1 correspond of a standard 72 DPI image     # The PdfPipelineOptions.generate_* are the selectors for the document elements which will be enriched     # with the image field     pipeline_options = PdfPipelineOptions()     pipeline_options.images_scale = IMAGE_RESOLUTION_SCALE     pipeline_options.generate_page_images = True     pipeline_options.generate_table_images = True     pipeline_options.generate_picture_images = True      doc_converter = DocumentConverter(         format_options={             InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)         }     )      start_time = time.time()      conv_res = doc_converter.convert(input_doc_path)      output_dir.mkdir(parents=True, exist_ok=True)     doc_filename = conv_res.input.file.stem      # Save page images     for page_no, page in conv_res.document.pages.items():         page_no = page.page_no         page_image_filename = output_dir / f\"{doc_filename}-{page_no}.png\"         with page_image_filename.open(\"wb\") as fp:             page.image.pil_image.save(fp, format=\"PNG\")      # Save images of figures and tables     table_counter = 0     picture_counter = 0     for element, _level in conv_res.document.iterate_items():         if isinstance(element, TableItem):             table_counter += 1             element_image_filename = (                 output_dir / f\"{doc_filename}-table-{table_counter}.png\"             )             with element_image_filename.open(\"wb\") as fp:                 element.image.pil_image.save(fp, \"PNG\")          if isinstance(element, PictureItem):             picture_counter += 1             element_image_filename = (                 output_dir / f\"{doc_filename}-picture-{picture_counter}.png\"             )             with element_image_filename.open(\"wb\") as fp:                 element.image.pil_image.save(fp, \"PNG\")      # Save markdown with embedded pictures     content_md = conv_res.document.export_to_markdown(image_mode=ImageRefMode.EMBEDDED)     md_filename = output_dir / f\"{doc_filename}-with-images.md\"     with md_filename.open(\"w\") as fp:         fp.write(content_md)      end_time = time.time() - start_time      _log.info(f\"Document converted and figures exported in {end_time:.2f} seconds.\") In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"},{"location":"examples/export_multimodal/","title":"Multimodal export","text":"In\u00a0[\u00a0]: Copied! <pre>import datetime\nimport logging\nimport time\nfrom pathlib import Path\n</pre> import datetime import logging import time from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import pandas as pd\n</pre> import pandas as pd In\u00a0[\u00a0]: Copied! <pre>from docling.datamodel.base_models import InputFormat\nfrom docling.datamodel.pipeline_options import PdfPipelineOptions\nfrom docling.document_converter import DocumentConverter, PdfFormatOption\nfrom docling.utils.export import generate_multimodal_pages\nfrom docling.utils.utils import create_hash\n</pre> from docling.datamodel.base_models import InputFormat from docling.datamodel.pipeline_options import PdfPipelineOptions from docling.document_converter import DocumentConverter, PdfFormatOption from docling.utils.export import generate_multimodal_pages from docling.utils.utils import create_hash In\u00a0[\u00a0]: Copied! <pre>_log = logging.getLogger(__name__)\n</pre> _log = logging.getLogger(__name__) In\u00a0[\u00a0]: Copied! <pre>IMAGE_RESOLUTION_SCALE = 2.0\n</pre> IMAGE_RESOLUTION_SCALE = 2.0 In\u00a0[\u00a0]: Copied! <pre>def main():\n    logging.basicConfig(level=logging.INFO)\n\n    input_doc_path = Path(\"./tests/data/2206.01062.pdf\")\n    output_dir = Path(\"scratch\")\n\n    # Important: For operating with page images, we must keep them, otherwise the DocumentConverter\n    # will destroy them for cleaning up memory.\n    # This is done by setting AssembleOptions.images_scale, which also defines the scale of images.\n    # scale=1 correspond of a standard 72 DPI image\n    pipeline_options = PdfPipelineOptions()\n    pipeline_options.images_scale = IMAGE_RESOLUTION_SCALE\n    pipeline_options.generate_page_images = True\n\n    doc_converter = DocumentConverter(\n        format_options={\n            InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)\n        }\n    )\n\n    start_time = time.time()\n\n    conv_res = doc_converter.convert(input_doc_path)\n\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    rows = []\n    for (\n        content_text,\n        content_md,\n        content_dt,\n        page_cells,\n        page_segments,\n        page,\n    ) in generate_multimodal_pages(conv_res):\n\n        dpi = page._default_image_scale * 72\n\n        rows.append(\n            {\n                \"document\": conv_res.input.file.name,\n                \"hash\": conv_res.input.document_hash,\n                \"page_hash\": create_hash(\n                    conv_res.input.document_hash + \":\" + str(page.page_no - 1)\n                ),\n                \"image\": {\n                    \"width\": page.image.width,\n                    \"height\": page.image.height,\n                    \"bytes\": page.image.tobytes(),\n                },\n                \"cells\": page_cells,\n                \"contents\": content_text,\n                \"contents_md\": content_md,\n                \"contents_dt\": content_dt,\n                \"segments\": page_segments,\n                \"extra\": {\n                    \"page_num\": page.page_no + 1,\n                    \"width_in_points\": page.size.width,\n                    \"height_in_points\": page.size.height,\n                    \"dpi\": dpi,\n                },\n            }\n        )\n\n    # Generate one parquet from all documents\n    df = pd.json_normalize(rows)\n    now = datetime.datetime.now()\n    output_filename = output_dir / f\"multimodal_{now:%Y-%m-%d_%H%M%S}.parquet\"\n    df.to_parquet(output_filename)\n\n    end_time = time.time() - start_time\n\n    _log.info(\n        f\"Document converted and multimodal pages generated in {end_time:.2f} seconds.\"\n    )\n\n    # This block demonstrates how the file can be opened with the HF datasets library\n    # from datasets import Dataset\n    # from PIL import Image\n    # multimodal_df = pd.read_parquet(output_filename)\n\n    # # Convert pandas DataFrame to Hugging Face Dataset and load bytes into image\n    # dataset = Dataset.from_pandas(multimodal_df)\n    # def transforms(examples):\n    #     examples[\"image\"] = Image.frombytes('RGB', (examples[\"image.width\"], examples[\"image.height\"]), examples[\"image.bytes\"], 'raw')\n    #     return examples\n    # dataset = dataset.map(transforms)\n</pre> def main():     logging.basicConfig(level=logging.INFO)      input_doc_path = Path(\"./tests/data/2206.01062.pdf\")     output_dir = Path(\"scratch\")      # Important: For operating with page images, we must keep them, otherwise the DocumentConverter     # will destroy them for cleaning up memory.     # This is done by setting AssembleOptions.images_scale, which also defines the scale of images.     # scale=1 correspond of a standard 72 DPI image     pipeline_options = PdfPipelineOptions()     pipeline_options.images_scale = IMAGE_RESOLUTION_SCALE     pipeline_options.generate_page_images = True      doc_converter = DocumentConverter(         format_options={             InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)         }     )      start_time = time.time()      conv_res = doc_converter.convert(input_doc_path)      output_dir.mkdir(parents=True, exist_ok=True)      rows = []     for (         content_text,         content_md,         content_dt,         page_cells,         page_segments,         page,     ) in generate_multimodal_pages(conv_res):          dpi = page._default_image_scale * 72          rows.append(             {                 \"document\": conv_res.input.file.name,                 \"hash\": conv_res.input.document_hash,                 \"page_hash\": create_hash(                     conv_res.input.document_hash + \":\" + str(page.page_no - 1)                 ),                 \"image\": {                     \"width\": page.image.width,                     \"height\": page.image.height,                     \"bytes\": page.image.tobytes(),                 },                 \"cells\": page_cells,                 \"contents\": content_text,                 \"contents_md\": content_md,                 \"contents_dt\": content_dt,                 \"segments\": page_segments,                 \"extra\": {                     \"page_num\": page.page_no + 1,                     \"width_in_points\": page.size.width,                     \"height_in_points\": page.size.height,                     \"dpi\": dpi,                 },             }         )      # Generate one parquet from all documents     df = pd.json_normalize(rows)     now = datetime.datetime.now()     output_filename = output_dir / f\"multimodal_{now:%Y-%m-%d_%H%M%S}.parquet\"     df.to_parquet(output_filename)      end_time = time.time() - start_time      _log.info(         f\"Document converted and multimodal pages generated in {end_time:.2f} seconds.\"     )      # This block demonstrates how the file can be opened with the HF datasets library     # from datasets import Dataset     # from PIL import Image     # multimodal_df = pd.read_parquet(output_filename)      # # Convert pandas DataFrame to Hugging Face Dataset and load bytes into image     # dataset = Dataset.from_pandas(multimodal_df)     # def transforms(examples):     #     examples[\"image\"] = Image.frombytes('RGB', (examples[\"image.width\"], examples[\"image.height\"]), examples[\"image.bytes\"], 'raw')     #     return examples     # dataset = dataset.map(transforms) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"},{"location":"examples/export_tables/","title":"Table export","text":"In\u00a0[\u00a0]: Copied! <pre>import logging\nimport time\nfrom pathlib import Path\n</pre> import logging import time from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import pandas as pd\n</pre> import pandas as pd In\u00a0[\u00a0]: Copied! <pre>from docling.document_converter import DocumentConverter\n</pre> from docling.document_converter import DocumentConverter In\u00a0[\u00a0]: Copied! <pre>_log = logging.getLogger(__name__)\n</pre> _log = logging.getLogger(__name__) In\u00a0[\u00a0]: Copied! <pre>def main():\n    logging.basicConfig(level=logging.INFO)\n\n    input_doc_path = Path(\"./tests/data/2206.01062.pdf\")\n    output_dir = Path(\"scratch\")\n\n    doc_converter = DocumentConverter()\n\n    start_time = time.time()\n\n    conv_res = doc_converter.convert(input_doc_path)\n\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    doc_filename = conv_res.input.file.stem\n\n    # Export tables\n    for table_ix, table in enumerate(conv_res.document.tables):\n        table_df: pd.DataFrame = table.export_to_dataframe()\n        print(f\"## Table {table_ix}\")\n        print(table_df.to_markdown())\n\n        # Save the table as csv\n        element_csv_filename = output_dir / f\"{doc_filename}-table-{table_ix+1}.csv\"\n        _log.info(f\"Saving CSV table to {element_csv_filename}\")\n        table_df.to_csv(element_csv_filename)\n\n        # Save the table as html\n        element_html_filename = output_dir / f\"{doc_filename}-table-{table_ix+1}.html\"\n        _log.info(f\"Saving HTML table to {element_html_filename}\")\n        with element_html_filename.open(\"w\") as fp:\n            fp.write(table.export_to_html())\n\n    end_time = time.time() - start_time\n\n    _log.info(f\"Document converted and tables exported in {end_time:.2f} seconds.\")\n</pre> def main():     logging.basicConfig(level=logging.INFO)      input_doc_path = Path(\"./tests/data/2206.01062.pdf\")     output_dir = Path(\"scratch\")      doc_converter = DocumentConverter()      start_time = time.time()      conv_res = doc_converter.convert(input_doc_path)      output_dir.mkdir(parents=True, exist_ok=True)      doc_filename = conv_res.input.file.stem      # Export tables     for table_ix, table in enumerate(conv_res.document.tables):         table_df: pd.DataFrame = table.export_to_dataframe()         print(f\"## Table {table_ix}\")         print(table_df.to_markdown())          # Save the table as csv         element_csv_filename = output_dir / f\"{doc_filename}-table-{table_ix+1}.csv\"         _log.info(f\"Saving CSV table to {element_csv_filename}\")         table_df.to_csv(element_csv_filename)          # Save the table as html         element_html_filename = output_dir / f\"{doc_filename}-table-{table_ix+1}.html\"         _log.info(f\"Saving HTML table to {element_html_filename}\")         with element_html_filename.open(\"w\") as fp:             fp.write(table.export_to_html())      end_time = time.time() - start_time      _log.info(f\"Document converted and tables exported in {end_time:.2f} seconds.\") In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"},{"location":"examples/full_page_ocr/","title":"Force full page OCR","text":"In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>from docling.backend.docling_parse_backend import DoclingParseDocumentBackend\nfrom docling.datamodel.base_models import InputFormat\nfrom docling.datamodel.pipeline_options import (\n    EasyOcrOptions,\n    PdfPipelineOptions,\n    TesseractCliOcrOptions,\n    TesseractOcrOptions,\n)\nfrom docling.document_converter import DocumentConverter, PdfFormatOption\n</pre> from docling.backend.docling_parse_backend import DoclingParseDocumentBackend from docling.datamodel.base_models import InputFormat from docling.datamodel.pipeline_options import (     EasyOcrOptions,     PdfPipelineOptions,     TesseractCliOcrOptions,     TesseractOcrOptions, ) from docling.document_converter import DocumentConverter, PdfFormatOption In\u00a0[\u00a0]: Copied! <pre>def main():\n    input_doc = Path(\"./tests/data/2206.01062.pdf\")\n\n    pipeline_options = PdfPipelineOptions()\n    pipeline_options.do_ocr = True\n    pipeline_options.do_table_structure = True\n    pipeline_options.table_structure_options.do_cell_matching = True\n\n    # Any of the OCR options can be used:EasyOcrOptions, TesseractOcrOptions, TesseractCliOcrOptions\n    # ocr_options = EasyOcrOptions(force_full_page_ocr=True)\n    # ocr_options = TesseractOcrOptions(force_full_page_ocr=True)\n    ocr_options = TesseractCliOcrOptions(force_full_page_ocr=True)\n    pipeline_options.ocr_options = ocr_options\n\n    converter = DocumentConverter(\n        format_options={\n            InputFormat.PDF: PdfFormatOption(\n                pipeline_options=pipeline_options,\n            )\n        }\n    )\n\n    doc = converter.convert(input_doc).document\n    md = doc.export_to_markdown()\n    print(md)\n</pre> def main():     input_doc = Path(\"./tests/data/2206.01062.pdf\")      pipeline_options = PdfPipelineOptions()     pipeline_options.do_ocr = True     pipeline_options.do_table_structure = True     pipeline_options.table_structure_options.do_cell_matching = True      # Any of the OCR options can be used:EasyOcrOptions, TesseractOcrOptions, TesseractCliOcrOptions     # ocr_options = EasyOcrOptions(force_full_page_ocr=True)     # ocr_options = TesseractOcrOptions(force_full_page_ocr=True)     ocr_options = TesseractCliOcrOptions(force_full_page_ocr=True)     pipeline_options.ocr_options = ocr_options      converter = DocumentConverter(         format_options={             InputFormat.PDF: PdfFormatOption(                 pipeline_options=pipeline_options,             )         }     )      doc = converter.convert(input_doc).document     md = doc.export_to_markdown()     print(md) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"},{"location":"examples/hybrid_rag_qdrant/","title":"Hybrid RAG with Qdrant","text":"<p>This example demonstrates using Docling with Qdrant to perform a hybrid search across your documents using dense and sparse vectors.</p> <p>We'll chunk the documents using Docling before adding them to a Qdrant collection. By limiting the length of the chunks, we can preserve the meaning in each vector embedding.</p> <ul> <li>\ud83d\udc49 Qdrant client uses FastEmbed to generate vector embeddings. You can install the <code>fastembed-gpu</code> package if you've got the hardware to support it.</li> </ul> In\u00a0[\u00a0]: Copied! <pre>%pip install --no-warn-conflicts -q qdrant-client docling docling-core fastembed\n</pre> %pip install --no-warn-conflicts -q qdrant-client docling docling-core fastembed <pre>\n[notice] A new release of pip is available: 24.2 -&gt; 24.3.1\n[notice] To update, run: pip install --upgrade pip\nNote: you may need to restart the kernel to use updated packages.\n</pre> <p>Let's import all the classes we'll be working with.</p> In\u00a0[1]: Copied! <pre>from docling_core.transforms.chunker import HierarchicalChunker\nfrom qdrant_client import QdrantClient\n\nfrom docling.datamodel.base_models import InputFormat\nfrom docling.document_converter import DocumentConverter\n</pre> from docling_core.transforms.chunker import HierarchicalChunker from qdrant_client import QdrantClient  from docling.datamodel.base_models import InputFormat from docling.document_converter import DocumentConverter <ul> <li>For Docling, we'll set the  allowed formats to HTML since we'll only be working with webpages in this tutorial.</li> <li>If we set a sparse model, Qdrant client will fuse the dense and sparse results using RRF. Reference.</li> </ul> In\u00a0[2]: Copied! <pre>COLLECTION_NAME = \"docling\"\n\ndoc_converter = DocumentConverter(allowed_formats=[InputFormat.HTML])\nclient = QdrantClient(location=\":memory:\")\n# The :memory: mode is a Python imitation of Qdrant's APIs for prototyping and CI.\n# For production deployments, use the Docker image: docker run -p 6333:6333 qdrant/qdrant\n# client = QdrantClient(location=\"http://localhost:6333\")\n\nclient.set_model(\"sentence-transformers/all-MiniLM-L6-v2\")\nclient.set_sparse_model(\"Qdrant/bm25\")\n</pre> COLLECTION_NAME = \"docling\"  doc_converter = DocumentConverter(allowed_formats=[InputFormat.HTML]) client = QdrantClient(location=\":memory:\") # The :memory: mode is a Python imitation of Qdrant's APIs for prototyping and CI. # For production deployments, use the Docker image: docker run -p 6333:6333 qdrant/qdrant # client = QdrantClient(location=\"http://localhost:6333\")  client.set_model(\"sentence-transformers/all-MiniLM-L6-v2\") client.set_sparse_model(\"Qdrant/bm25\") <pre>Fetching 5 files:   0%|          | 0/5 [00:00&lt;?, ?it/s]</pre> <pre>Fetching 29 files:   0%|          | 0/29 [00:00&lt;?, ?it/s]</pre> <p>We can now download and chunk the document using Docling. For demonstration, we'll use an article about chunking strategies :)</p> In\u00a0[3]: Copied! <pre>result = doc_converter.convert(\n    \"https://www.sagacify.com/news/a-guide-to-chunking-strategies-for-retrieval-augmented-generation-rag\"\n)\ndocuments, metadatas = [], []\nfor chunk in HierarchicalChunker().chunk(result.document):\n    documents.append(chunk.text)\n    metadatas.append(chunk.meta.export_json_dict())\n</pre> result = doc_converter.convert(     \"https://www.sagacify.com/news/a-guide-to-chunking-strategies-for-retrieval-augmented-generation-rag\" ) documents, metadatas = [], [] for chunk in HierarchicalChunker().chunk(result.document):     documents.append(chunk.text)     metadatas.append(chunk.meta.export_json_dict()) <p>Let's now upload the documents to Qdrant.</p> <ul> <li>The <code>add()</code> method batches the documents and uses FastEmbed to generate vector embeddings on our machine.</li> </ul> In\u00a0[4]: Copied! <pre>client.add(COLLECTION_NAME, documents=documents, metadata=metadatas, batch_size=64)\n</pre> client.add(COLLECTION_NAME, documents=documents, metadata=metadatas, batch_size=64) Out[4]: <pre>['e74ae15be5eb4805858307846318e784',\n 'f83f6125b0fa4a0595ae6a0777c9d90d',\n '9cf63c7f30764715bf3804a19db36d7d',\n '007dbe6d355b4b49af3b736cbd63a4d8',\n 'e5e31f21f2e84aa68beca0dfc532cbe9',\n '69c10816af204bb28630a1f957d8dd3e',\n 'b63546b9b1744063bdb076b234d883ca',\n '90ad15ba8fa6494489e1d3221e30bfcf',\n '13517debb483452ea40fc7aa04c08c50',\n '84ccab5cfab74e27a55acef1c63e3fad',\n 'e8aa2ef46d234c5a8a9da64b701d60b4',\n '190bea5ba43c45e792197c50898d1d90',\n 'a730319ea65645ca81e735ace0bcc72e',\n '415e7f6f15864e30b836e23ae8d71b43',\n '5569bce4e65541868c762d149c6f491e',\n '74d9b234e9c04ebeb8e4e1ca625789ac',\n '308b1c5006a94a679f4c8d6f2396993c',\n 'aaa5ec6d385a418388e660c425bf1dbe',\n '630be8e43e4e4472a9cdb9af9462a43a',\n '643b316224de4770a5349bf69cf93471',\n 'da9265e6f6c2485493d15223eefdf411',\n 'a916e447d52c4084b5ce81a0c5a65b07',\n '2883c620858e4e728b88e127155a4f2c',\n '2a998f0e9c124af99027060b94027874',\n 'be551fbd2b9e42f48ebae0cbf1f481bc',\n '95b7f7608e974ca6847097ee4590fba1',\n '309db4f3863b4e3aaf16d5f346c309f3',\n 'c818383267f64fd68b2237b024bd724e',\n '1f16e78338c94238892171b400051cd4',\n '25c680c3e064462cab071ea9bf1bad8c',\n 'f41ab7e480a248c6bb87019341c7ca74',\n 'd440128bed6d4dcb987152b48ecd9a8a',\n 'c110d5dfdc5849808851788c2404dd15']</pre> In\u00a0[5]: Copied! <pre>points = client.query(COLLECTION_NAME, query_text=\"Can I split documents?\", limit=10)\n\nprint(\"&lt;=== Retrieved documents ===&gt;\")\nfor point in points:\n    print(point.document)\n</pre> points = client.query(COLLECTION_NAME, query_text=\"Can I split documents?\", limit=10)  print(\"&lt;=== Retrieved documents ===&gt;\") for point in points:     print(point.document) <pre>&lt;=== Retrieved documents ===&gt;\nDocument Specific Chunking is a strategy that respects the document's structure. Rather than using a set number of characters or a recursive process, it creates chunks that align with the logical sections of the document, like paragraphs or subsections. This approach maintains the original author's organization of content and helps keep the text coherent. It makes the retrieved information more relevant and useful, particularly for structured documents with clearly defined sections.\nDocument Specific Chunking can handle a variety of document formats, such as:\nConsequently, there are also splitters available for this purpose.\n1. We start at the top of the document, treating the first part as a chunk.\n\u00a0\u00a0\u00a02. We continue down the document, deciding if a new sentence or piece of information belongs with the first chunk or should start a new one.\n \u00a0\u00a0\u00a03. We keep this up until we reach the end of the document.\nHave you ever wondered how we, humans, would chunk? Here's a breakdown of a possible way a human would process a new document:\nThe goal of chunking is, as its name says, to chunk the information into multiple smaller pieces in order to store it in a more efficient and meaningful way. This allows the retrieval to capture pieces of information that are more related to the question at hand, and the generation to be more precise, but also less costly, as only a part of a document will be included in the LLM prompt, instead of the whole document.\nTo put these strategies into action, there's a whole array of tools and libraries at your disposal. For example, llama_index is a fantastic tool that lets you create document indices and retrieve chunked documents. Let's not forget LangChain, another remarkable tool that makes implementing chunking strategies a breeze, particularly when dealing with multi-language data. Diving into these tools and understanding how they can work in harmony with the chunking strategies we've discussed is a crucial part of mastering Retrieval Augmented Generation.\nSemantic chunking involves taking the embeddings of every sentence in the document, comparing the similarity of all sentences with each other, and then grouping sentences with the most similar embeddings together.\nYou can see here that with a chunk size of 105, the Markdown structure of the document is taken into account, and the chunks thus preserve the semantics of the text!\nAnd there you have it! These chunking strategies are like a personal toolbox when it comes to implementing Retrieval Augmented Generation. They're a ton of ways to slice and dice text, each with its unique features and quirks. This variety gives you the freedom to pick the strategy that suits your project best, allowing you to tailor your approach to perfectly fit the unique needs of your work.\n</pre>"},{"location":"examples/hybrid_rag_qdrant/#hybrid-rag-with-qdrant","title":"Hybrid RAG with Qdrant\u00b6","text":""},{"location":"examples/hybrid_rag_qdrant/#overview","title":"Overview\u00b6","text":""},{"location":"examples/hybrid_rag_qdrant/#setup","title":"Setup\u00b6","text":""},{"location":"examples/hybrid_rag_qdrant/#query-documents","title":"Query Documents\u00b6","text":""},{"location":"examples/minimal/","title":"Simple conversion","text":"In\u00a0[\u00a0]: Copied! <pre>from docling.document_converter import DocumentConverter\n</pre> from docling.document_converter import DocumentConverter In\u00a0[\u00a0]: Copied! <pre>source = \"https://arxiv.org/pdf/2408.09869\"  # document per local path or URL\nconverter = DocumentConverter()\nresult = converter.convert(source)\nprint(result.document.export_to_markdown())\n# output: ## Docling Technical Report [...]\"\n</pre> source = \"https://arxiv.org/pdf/2408.09869\"  # document per local path or URL converter = DocumentConverter() result = converter.convert(source) print(result.document.export_to_markdown()) # output: ## Docling Technical Report [...]\""},{"location":"examples/rag_langchain/","title":"RAG with LangChain \ud83e\udd9c\ud83d\udd17","text":"In\u00a0[1]: Copied! <pre># requirements for this example:\n%pip install -qq docling docling-core python-dotenv langchain-text-splitters langchain-huggingface langchain-milvus\n</pre> # requirements for this example: %pip install -qq docling docling-core python-dotenv langchain-text-splitters langchain-huggingface langchain-milvus <pre>Note: you may need to restart the kernel to use updated packages.\n</pre> In\u00a0[2]: Copied! <pre>import os\n\nfrom dotenv import load_dotenv\n\nload_dotenv()\n</pre> import os  from dotenv import load_dotenv  load_dotenv() Out[2]: <pre>True</pre> <p>Below we set up:</p> <ul> <li>a <code>Loader</code> which will be used to create LangChain documents, and</li> <li>a splitter, which will be used to split these documents</li> </ul> In\u00a0[3]: Copied! <pre>from typing import Iterator\n\nfrom langchain_core.document_loaders import BaseLoader\nfrom langchain_core.documents import Document as LCDocument\n\nfrom docling.document_converter import DocumentConverter\n\nclass DoclingPDFLoader(BaseLoader):\n\n    def __init__(self, file_path: str | list[str]) -&gt; None:\n        self._file_paths = file_path if isinstance(file_path, list) else [file_path]\n        self._converter = DocumentConverter()\n\n    def lazy_load(self) -&gt; Iterator[LCDocument]:\n        for source in self._file_paths:\n            dl_doc = self._converter.convert(source).document\n            text = dl_doc.export_to_markdown()\n            yield LCDocument(page_content=text)\n</pre> from typing import Iterator  from langchain_core.document_loaders import BaseLoader from langchain_core.documents import Document as LCDocument  from docling.document_converter import DocumentConverter  class DoclingPDFLoader(BaseLoader):      def __init__(self, file_path: str | list[str]) -&gt; None:         self._file_paths = file_path if isinstance(file_path, list) else [file_path]         self._converter = DocumentConverter()      def lazy_load(self) -&gt; Iterator[LCDocument]:         for source in self._file_paths:             dl_doc = self._converter.convert(source).document             text = dl_doc.export_to_markdown()             yield LCDocument(page_content=text) In\u00a0[4]: Copied! <pre>FILE_PATH = \"https://raw.githubusercontent.com/DS4SD/docling/main/tests/data/2206.01062.pdf\"  # DocLayNet paper\n</pre> FILE_PATH = \"https://raw.githubusercontent.com/DS4SD/docling/main/tests/data/2206.01062.pdf\"  # DocLayNet paper In\u00a0[5]: Copied! <pre>from langchain_text_splitters import RecursiveCharacterTextSplitter\n\nloader = DoclingPDFLoader(file_path=FILE_PATH)\ntext_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=1000,\n    chunk_overlap=200,\n)\n</pre> from langchain_text_splitters import RecursiveCharacterTextSplitter  loader = DoclingPDFLoader(file_path=FILE_PATH) text_splitter = RecursiveCharacterTextSplitter(     chunk_size=1000,     chunk_overlap=200, ) <p>We now used the above-defined objects to get the document splits:</p> In\u00a0[6]: Copied! <pre>docs = loader.load()\nsplits = text_splitter.split_documents(docs)\n</pre> docs = loader.load() splits = text_splitter.split_documents(docs) In\u00a0[7]: Copied! <pre>from langchain_huggingface.embeddings import HuggingFaceEmbeddings\n\nHF_EMBED_MODEL_ID = \"BAAI/bge-small-en-v1.5\"\nembeddings = HuggingFaceEmbeddings(model_name=HF_EMBED_MODEL_ID)\n</pre> from langchain_huggingface.embeddings import HuggingFaceEmbeddings  HF_EMBED_MODEL_ID = \"BAAI/bge-small-en-v1.5\" embeddings = HuggingFaceEmbeddings(model_name=HF_EMBED_MODEL_ID) In\u00a0[8]: Copied! <pre>from tempfile import TemporaryDirectory\n\nfrom langchain_milvus import Milvus\n\nMILVUS_URI = os.environ.get(\n    \"MILVUS_URI\", f\"{(tmp_dir := TemporaryDirectory()).name}/milvus_demo.db\"\n)\n\nvectorstore = Milvus.from_documents(\n    splits,\n    embeddings,\n    connection_args={\"uri\": MILVUS_URI},\n    drop_old=True,\n)\n</pre> from tempfile import TemporaryDirectory  from langchain_milvus import Milvus  MILVUS_URI = os.environ.get(     \"MILVUS_URI\", f\"{(tmp_dir := TemporaryDirectory()).name}/milvus_demo.db\" )  vectorstore = Milvus.from_documents(     splits,     embeddings,     connection_args={\"uri\": MILVUS_URI},     drop_old=True, ) In\u00a0[9]: Copied! <pre>from langchain_huggingface import HuggingFaceEndpoint\n\nHF_API_KEY = os.environ.get(\"HF_API_KEY\")\nHF_LLM_MODEL_ID = \"mistralai/Mistral-7B-Instruct-v0.3\"\n\nllm = HuggingFaceEndpoint(\n    repo_id=HF_LLM_MODEL_ID,\n    huggingfacehub_api_token=HF_API_KEY,\n)\n</pre> from langchain_huggingface import HuggingFaceEndpoint  HF_API_KEY = os.environ.get(\"HF_API_KEY\") HF_LLM_MODEL_ID = \"mistralai/Mistral-7B-Instruct-v0.3\"  llm = HuggingFaceEndpoint(     repo_id=HF_LLM_MODEL_ID,     huggingfacehub_api_token=HF_API_KEY, ) <pre>The token has not been saved to the git credentials helper. Pass `add_to_git_credential=True` in this function directly or `--add-to-git-credential` if using via `huggingface-cli` if you want to set the git credential as well.\nToken is valid (permission: write).\nYour token has been saved to /Users/pva/.cache/huggingface/token\nLogin successful\n</pre> In\u00a0[10]: Copied! <pre>from typing import Iterable\n\nfrom langchain_core.documents import Document as LCDocument\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain_core.runnables import RunnablePassthrough\n\n\ndef format_docs(docs: Iterable[LCDocument]):\n    return \"\\n\\n\".join(doc.page_content for doc in docs)\n\n\nretriever = vectorstore.as_retriever()\n\nprompt = PromptTemplate.from_template(\n    \"Context information is below.\\n---------------------\\n{context}\\n---------------------\\nGiven the context information and not prior knowledge, answer the query.\\nQuery: {question}\\nAnswer:\\n\"\n)\n\nrag_chain = (\n    {\"context\": retriever | format_docs, \"question\": RunnablePassthrough()}\n    | prompt\n    | llm\n    | StrOutputParser()\n)\n</pre> from typing import Iterable  from langchain_core.documents import Document as LCDocument from langchain_core.output_parsers import StrOutputParser from langchain_core.prompts import PromptTemplate from langchain_core.runnables import RunnablePassthrough   def format_docs(docs: Iterable[LCDocument]):     return \"\\n\\n\".join(doc.page_content for doc in docs)   retriever = vectorstore.as_retriever()  prompt = PromptTemplate.from_template(     \"Context information is below.\\n---------------------\\n{context}\\n---------------------\\nGiven the context information and not prior knowledge, answer the query.\\nQuery: {question}\\nAnswer:\\n\" )  rag_chain = (     {\"context\": retriever | format_docs, \"question\": RunnablePassthrough()}     | prompt     | llm     | StrOutputParser() ) In\u00a0[11]: Copied! <pre>rag_chain.invoke(\"How many pages were human annotated for DocLayNet?\")\n</pre> rag_chain.invoke(\"How many pages were human annotated for DocLayNet?\") Out[11]: <pre>'- 80,863 pages were human annotated for DocLayNet.'</pre>"},{"location":"examples/rag_langchain/#rag-with-langchain","title":"RAG with LangChain \ud83e\udd9c\ud83d\udd17\u00b6","text":""},{"location":"examples/rag_langchain/#setup","title":"Setup\u00b6","text":""},{"location":"examples/rag_langchain/#loader-and-splitter","title":"Loader and splitter\u00b6","text":""},{"location":"examples/rag_langchain/#embeddings","title":"Embeddings\u00b6","text":""},{"location":"examples/rag_langchain/#vector-store","title":"Vector store\u00b6","text":""},{"location":"examples/rag_langchain/#llm","title":"LLM\u00b6","text":""},{"location":"examples/rag_langchain/#rag","title":"RAG\u00b6","text":""},{"location":"examples/rag_llamaindex/","title":"RAG with LlamaIndex \ud83e\udd99","text":"<p>This example leverages the official LlamaIndex Docling extension.</p> <p>Presented extensions <code>DoclingReader</code> and <code>DoclingNodeParser</code> enable you to:</p> <ul> <li>use various document types in your LLM applications with ease and speed, and</li> <li>leverage Docling's rich format for advanced, document-native grounding.</li> </ul> <ul> <li>\ud83d\udc49 For best conversion speed, use GPU acceleration whenever available; e.g. if running on Colab, use GPU-enabled runtime.</li> <li>Notebook uses HuggingFace's Inference API; for increased LLM quota, token can be provided via env var <code>HF_TOKEN</code>.</li> <li>Requirements can be installed as shown below (<code>--no-warn-conflicts</code> meant for Colab's pre-populated Python env; feel free to remove for stricter usage):</li> </ul> In\u00a0[1]: Copied! <pre>%pip install -q --progress-bar off --no-warn-conflicts llama-index-core llama-index-readers-docling llama-index-node-parser-docling llama-index-embeddings-huggingface llama-index-llms-huggingface-api llama-index-vector-stores-milvus llama-index-readers-file python-dotenv\n</pre> %pip install -q --progress-bar off --no-warn-conflicts llama-index-core llama-index-readers-docling llama-index-node-parser-docling llama-index-embeddings-huggingface llama-index-llms-huggingface-api llama-index-vector-stores-milvus llama-index-readers-file python-dotenv <pre>Note: you may need to restart the kernel to use updated packages.\n</pre> In\u00a0[2]: Copied! <pre>import os\nfrom pathlib import Path\nfrom tempfile import mkdtemp\nfrom warnings import filterwarnings\n\nfrom dotenv import load_dotenv\n\n\ndef _get_env_from_colab_or_os(key):\n    try:\n        from google.colab import userdata\n\n        try:\n            return userdata.get(key)\n        except userdata.SecretNotFoundError:\n            pass\n    except ImportError:\n        pass\n    return os.getenv(key)\n\n\nload_dotenv()\n\nfilterwarnings(action=\"ignore\", category=UserWarning, module=\"pydantic\")\nfilterwarnings(action=\"ignore\", category=FutureWarning, module=\"easyocr\")\n# https://github.com/huggingface/transformers/issues/5486:\nos.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"\n</pre> import os from pathlib import Path from tempfile import mkdtemp from warnings import filterwarnings  from dotenv import load_dotenv   def _get_env_from_colab_or_os(key):     try:         from google.colab import userdata          try:             return userdata.get(key)         except userdata.SecretNotFoundError:             pass     except ImportError:         pass     return os.getenv(key)   load_dotenv()  filterwarnings(action=\"ignore\", category=UserWarning, module=\"pydantic\") filterwarnings(action=\"ignore\", category=FutureWarning, module=\"easyocr\") # https://github.com/huggingface/transformers/issues/5486: os.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\" <p>We can now define the main parameters:</p> In\u00a0[3]: Copied! <pre>from llama_index.embeddings.huggingface import HuggingFaceEmbedding\nfrom llama_index.llms.huggingface_api import HuggingFaceInferenceAPI\n\nEMBED_MODEL = HuggingFaceEmbedding(model_name=\"BAAI/bge-small-en-v1.5\")\nMILVUS_URI = str(Path(mkdtemp()) / \"docling.db\")\nGEN_MODEL = HuggingFaceInferenceAPI(\n    token=_get_env_from_colab_or_os(\"HF_TOKEN\"),\n    model_name=\"mistralai/Mixtral-8x7B-Instruct-v0.1\",\n)\nSOURCE = \"https://arxiv.org/pdf/2408.09869\"  # Docling Technical Report\nQUERY = \"Which are the main AI models in Docling?\"\n\nembed_dim = len(EMBED_MODEL.get_text_embedding(\"hi\"))\n</pre> from llama_index.embeddings.huggingface import HuggingFaceEmbedding from llama_index.llms.huggingface_api import HuggingFaceInferenceAPI  EMBED_MODEL = HuggingFaceEmbedding(model_name=\"BAAI/bge-small-en-v1.5\") MILVUS_URI = str(Path(mkdtemp()) / \"docling.db\") GEN_MODEL = HuggingFaceInferenceAPI(     token=_get_env_from_colab_or_os(\"HF_TOKEN\"),     model_name=\"mistralai/Mixtral-8x7B-Instruct-v0.1\", ) SOURCE = \"https://arxiv.org/pdf/2408.09869\"  # Docling Technical Report QUERY = \"Which are the main AI models in Docling?\"  embed_dim = len(EMBED_MODEL.get_text_embedding(\"hi\")) <p>To create a simple RAG pipeline, we can:</p> <ul> <li>define a <code>DoclingReader</code>, which by default exports to Markdown, and</li> <li>use a standard node parser for these Markdown-based docs, e.g. a <code>MarkdownNodeParser</code></li> </ul> In\u00a0[4]: Copied! <pre>from llama_index.core import StorageContext, VectorStoreIndex\nfrom llama_index.core.node_parser import MarkdownNodeParser\nfrom llama_index.readers.docling import DoclingReader\nfrom llama_index.vector_stores.milvus import MilvusVectorStore\n\nreader = DoclingReader()\nnode_parser = MarkdownNodeParser()\n\nvector_store = MilvusVectorStore(\n    uri=str(Path(mkdtemp()) / \"docling.db\"),  # or set as needed\n    dim=embed_dim,\n    overwrite=True,\n)\nindex = VectorStoreIndex.from_documents(\n    documents=reader.load_data(SOURCE),\n    transformations=[node_parser],\n    storage_context=StorageContext.from_defaults(vector_store=vector_store),\n    embed_model=EMBED_MODEL,\n)\nresult = index.as_query_engine(llm=GEN_MODEL).query(QUERY)\nprint(f\"Q: {QUERY}\\nA: {result.response.strip()}\\n\\nSources:\")\ndisplay([(n.text, n.metadata) for n in result.source_nodes])\n</pre> from llama_index.core import StorageContext, VectorStoreIndex from llama_index.core.node_parser import MarkdownNodeParser from llama_index.readers.docling import DoclingReader from llama_index.vector_stores.milvus import MilvusVectorStore  reader = DoclingReader() node_parser = MarkdownNodeParser()  vector_store = MilvusVectorStore(     uri=str(Path(mkdtemp()) / \"docling.db\"),  # or set as needed     dim=embed_dim,     overwrite=True, ) index = VectorStoreIndex.from_documents(     documents=reader.load_data(SOURCE),     transformations=[node_parser],     storage_context=StorageContext.from_defaults(vector_store=vector_store),     embed_model=EMBED_MODEL, ) result = index.as_query_engine(llm=GEN_MODEL).query(QUERY) print(f\"Q: {QUERY}\\nA: {result.response.strip()}\\n\\nSources:\") display([(n.text, n.metadata) for n in result.source_nodes]) <pre>Q: Which are the main AI models in Docling?\nA: The main AI models in Docling are a layout analysis model, which is an accurate object-detector for page elements, and TableFormer, a state-of-the-art table structure recognition model.\n\nSources:\n</pre> <pre>[('3.2 AI models\\n\\nAs part of Docling, we initially release two highly capable AI models to the open-source community, which have been developed and published recently by our team. The first model is a layout analysis model, an accurate object-detector for page elements [13]. The second model is TableFormer [12, 9], a state-of-the-art table structure recognition model. We provide the pre-trained weights (hosted on huggingface) and a separate package for the inference code as docling-ibm-models . Both models are also powering the open-access deepsearch-experience, our cloud-native service for knowledge exploration tasks.',\n  {'Header_2': '3.2 AI models'}),\n (\"5 Applications\\n\\nThanks to the high-quality, richly structured document conversion achieved by Docling, its output qualifies for numerous downstream applications. For example, Docling can provide a base for detailed enterprise document search, passage retrieval or classification use-cases, or support knowledge extraction pipelines, allowing specific treatment of different structures in the document, such as tables, figures, section structure or references. For popular generative AI application patterns, such as retrieval-augmented generation (RAG), we provide quackling , an open-source package which capitalizes on Docling's feature-rich document output to enable document-native optimized vector embedding and chunking. It plugs in seamlessly with LLM frameworks such as LlamaIndex [8]. Since Docling is fast, stable and cheap to run, it also makes for an excellent choice to build document-derived datasets. With its powerful table structure recognition, it provides significant benefit to automated knowledge-base construction [11, 10]. Docling is also integrated within the open IBM data prep kit [6], which implements scalable data transforms to build large-scale multi-modal training datasets.\",\n  {'Header_2': '5 Applications'})]</pre> <p>To leverage Docling's rich native format, we:</p> <ul> <li>create a <code>DoclingReader</code> with JSON export type, and</li> <li>employ a <code>DoclingNodeParser</code> in order to appropriately parse that Docling format.</li> </ul> <p>Notice how the sources now also contain document-level grounding (e.g. page number or bounding box information):</p> In\u00a0[5]: Copied! <pre>from llama_index.node_parser.docling import DoclingNodeParser\n\nreader = DoclingReader(export_type=DoclingReader.ExportType.JSON)\nnode_parser = DoclingNodeParser()\n\nvector_store = MilvusVectorStore(\n    uri=str(Path(mkdtemp()) / \"docling.db\"),  # or set as needed\n    dim=embed_dim,\n    overwrite=True,\n)\nindex = VectorStoreIndex.from_documents(\n    documents=reader.load_data(SOURCE),\n    transformations=[node_parser],\n    storage_context=StorageContext.from_defaults(vector_store=vector_store),\n    embed_model=EMBED_MODEL,\n)\nresult = index.as_query_engine(llm=GEN_MODEL).query(QUERY)\nprint(f\"Q: {QUERY}\\nA: {result.response.strip()}\\n\\nSources:\")\ndisplay([(n.text, n.metadata) for n in result.source_nodes])\n</pre> from llama_index.node_parser.docling import DoclingNodeParser  reader = DoclingReader(export_type=DoclingReader.ExportType.JSON) node_parser = DoclingNodeParser()  vector_store = MilvusVectorStore(     uri=str(Path(mkdtemp()) / \"docling.db\"),  # or set as needed     dim=embed_dim,     overwrite=True, ) index = VectorStoreIndex.from_documents(     documents=reader.load_data(SOURCE),     transformations=[node_parser],     storage_context=StorageContext.from_defaults(vector_store=vector_store),     embed_model=EMBED_MODEL, ) result = index.as_query_engine(llm=GEN_MODEL).query(QUERY) print(f\"Q: {QUERY}\\nA: {result.response.strip()}\\n\\nSources:\") display([(n.text, n.metadata) for n in result.source_nodes]) <pre>Q: Which are the main AI models in Docling?\nA: The main AI models in Docling are a layout analysis model and TableFormer. The layout analysis model is an accurate object-detector for page elements, and TableFormer is a state-of-the-art table structure recognition model.\n\nSources:\n</pre> <pre>[('As part of Docling, we initially release two highly capable AI models to the open-source community, which have been developed and published recently by our team. The first model is a layout analysis model, an accurate object-detector for page elements [13]. The second model is TableFormer [12, 9], a state-of-the-art table structure recognition model. We provide the pre-trained weights (hosted on huggingface) and a separate package for the inference code as docling-ibm-models . Both models are also powering the open-access deepsearch-experience, our cloud-native service for knowledge exploration tasks.',\n  {'schema_name': 'docling_core.transforms.chunker.DocMeta',\n   'version': '1.0.0',\n   'doc_items': [{'self_ref': '#/texts/34',\n     'parent': {'$ref': '#/body'},\n     'children': [],\n     'label': 'text',\n     'prov': [{'page_no': 3,\n       'bbox': {'l': 107.07593536376953,\n        't': 406.1695251464844,\n        'r': 504.1148681640625,\n        'b': 330.2677307128906,\n        'coord_origin': 'BOTTOMLEFT'},\n       'charspan': [0, 608]}]}],\n   'headings': ['3.2 AI models'],\n   'origin': {'mimetype': 'application/pdf',\n    'binary_hash': 14981478401387673002,\n    'filename': '2408.09869v3.pdf'}}),\n ('With Docling , we open-source a very capable and efficient document conversion tool which builds on the powerful, specialized AI models and datasets for layout analysis and table structure recognition we developed and presented in the recent past [12, 13, 9]. Docling is designed as a simple, self-contained python library with permissive license, running entirely locally on commodity hardware. Its code architecture allows for easy extensibility and addition of new features and models.',\n  {'schema_name': 'docling_core.transforms.chunker.DocMeta',\n   'version': '1.0.0',\n   'doc_items': [{'self_ref': '#/texts/9',\n     'parent': {'$ref': '#/body'},\n     'children': [],\n     'label': 'text',\n     'prov': [{'page_no': 1,\n       'bbox': {'l': 107.0031967163086,\n        't': 136.7283935546875,\n        'r': 504.04998779296875,\n        'b': 83.30133056640625,\n        'coord_origin': 'BOTTOMLEFT'},\n       'charspan': [0, 488]}]}],\n   'headings': ['1 Introduction'],\n   'origin': {'mimetype': 'application/pdf',\n    'binary_hash': 14981478401387673002,\n    'filename': '2408.09869v3.pdf'}})]</pre> <p>To demonstrate this usage pattern, we first set up a test document directory.</p> In\u00a0[6]: Copied! <pre>from pathlib import Path\nfrom tempfile import mkdtemp\n\nimport requests\n\ntmp_dir_path = Path(mkdtemp())\nr = requests.get(SOURCE)\nwith open(tmp_dir_path / f\"{Path(SOURCE).name}.pdf\", \"wb\") as out_file:\n    out_file.write(r.content)\n</pre> from pathlib import Path from tempfile import mkdtemp  import requests  tmp_dir_path = Path(mkdtemp()) r = requests.get(SOURCE) with open(tmp_dir_path / f\"{Path(SOURCE).name}.pdf\", \"wb\") as out_file:     out_file.write(r.content) <p>Using the <code>reader</code> and <code>node_parser</code> definitions from any of the above variants, usage with <code>SimpleDirectoryReader</code> then looks as follows:</p> In\u00a0[7]: Copied! <pre>from llama_index.core import SimpleDirectoryReader\n\ndir_reader = SimpleDirectoryReader(\n    input_dir=tmp_dir_path,\n    file_extractor={\".pdf\": reader},\n)\n\nvector_store = MilvusVectorStore(\n    uri=str(Path(mkdtemp()) / \"docling.db\"),  # or set as needed\n    dim=embed_dim,\n    overwrite=True,\n)\nindex = VectorStoreIndex.from_documents(\n    documents=dir_reader.load_data(SOURCE),\n    transformations=[node_parser],\n    storage_context=StorageContext.from_defaults(vector_store=vector_store),\n    embed_model=EMBED_MODEL,\n)\nresult = index.as_query_engine(llm=GEN_MODEL).query(QUERY)\nprint(f\"Q: {QUERY}\\nA: {result.response.strip()}\\n\\nSources:\")\ndisplay([(n.text, n.metadata) for n in result.source_nodes])\n</pre> from llama_index.core import SimpleDirectoryReader  dir_reader = SimpleDirectoryReader(     input_dir=tmp_dir_path,     file_extractor={\".pdf\": reader}, )  vector_store = MilvusVectorStore(     uri=str(Path(mkdtemp()) / \"docling.db\"),  # or set as needed     dim=embed_dim,     overwrite=True, ) index = VectorStoreIndex.from_documents(     documents=dir_reader.load_data(SOURCE),     transformations=[node_parser],     storage_context=StorageContext.from_defaults(vector_store=vector_store),     embed_model=EMBED_MODEL, ) result = index.as_query_engine(llm=GEN_MODEL).query(QUERY) print(f\"Q: {QUERY}\\nA: {result.response.strip()}\\n\\nSources:\") display([(n.text, n.metadata) for n in result.source_nodes]) <pre>Loading files: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:11&lt;00:00, 11.27s/file]\n</pre> <pre>Q: Which are the main AI models in Docling?\nA: 1. A layout analysis model, an accurate object-detector for page elements. 2. TableFormer, a state-of-the-art table structure recognition model.\n\nSources:\n</pre> <pre>[('As part of Docling, we initially release two highly capable AI models to the open-source community, which have been developed and published recently by our team. The first model is a layout analysis model, an accurate object-detector for page elements [13]. The second model is TableFormer [12, 9], a state-of-the-art table structure recognition model. We provide the pre-trained weights (hosted on huggingface) and a separate package for the inference code as docling-ibm-models . Both models are also powering the open-access deepsearch-experience, our cloud-native service for knowledge exploration tasks.',\n  {'file_path': '/var/folders/76/4wwfs06x6835kcwj4186c0nc0000gn/T/tmp2ooyusg5/2408.09869.pdf',\n   'file_name': '2408.09869.pdf',\n   'file_type': 'application/pdf',\n   'file_size': 5566574,\n   'creation_date': '2024-10-28',\n   'last_modified_date': '2024-10-28',\n   'schema_name': 'docling_core.transforms.chunker.DocMeta',\n   'version': '1.0.0',\n   'doc_items': [{'self_ref': '#/texts/34',\n     'parent': {'$ref': '#/body'},\n     'children': [],\n     'label': 'text',\n     'prov': [{'page_no': 3,\n       'bbox': {'l': 107.07593536376953,\n        't': 406.1695251464844,\n        'r': 504.1148681640625,\n        'b': 330.2677307128906,\n        'coord_origin': 'BOTTOMLEFT'},\n       'charspan': [0, 608]}]}],\n   'headings': ['3.2 AI models'],\n   'origin': {'mimetype': 'application/pdf',\n    'binary_hash': 14981478401387673002,\n    'filename': '2408.09869.pdf'}}),\n ('With Docling , we open-source a very capable and efficient document conversion tool which builds on the powerful, specialized AI models and datasets for layout analysis and table structure recognition we developed and presented in the recent past [12, 13, 9]. Docling is designed as a simple, self-contained python library with permissive license, running entirely locally on commodity hardware. Its code architecture allows for easy extensibility and addition of new features and models.',\n  {'file_path': '/var/folders/76/4wwfs06x6835kcwj4186c0nc0000gn/T/tmp2ooyusg5/2408.09869.pdf',\n   'file_name': '2408.09869.pdf',\n   'file_type': 'application/pdf',\n   'file_size': 5566574,\n   'creation_date': '2024-10-28',\n   'last_modified_date': '2024-10-28',\n   'schema_name': 'docling_core.transforms.chunker.DocMeta',\n   'version': '1.0.0',\n   'doc_items': [{'self_ref': '#/texts/9',\n     'parent': {'$ref': '#/body'},\n     'children': [],\n     'label': 'text',\n     'prov': [{'page_no': 1,\n       'bbox': {'l': 107.0031967163086,\n        't': 136.7283935546875,\n        'r': 504.04998779296875,\n        'b': 83.30133056640625,\n        'coord_origin': 'BOTTOMLEFT'},\n       'charspan': [0, 488]}]}],\n   'headings': ['1 Introduction'],\n   'origin': {'mimetype': 'application/pdf',\n    'binary_hash': 14981478401387673002,\n    'filename': '2408.09869.pdf'}})]</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/rag_llamaindex/#rag-with-llamaindex","title":"RAG with LlamaIndex \ud83e\udd99\u00b6","text":""},{"location":"examples/rag_llamaindex/#overview","title":"Overview\u00b6","text":""},{"location":"examples/rag_llamaindex/#setup","title":"Setup\u00b6","text":""},{"location":"examples/rag_llamaindex/#using-markdown-export","title":"Using Markdown export\u00b6","text":""},{"location":"examples/rag_llamaindex/#using-docling-format","title":"Using Docling format\u00b6","text":""},{"location":"examples/rag_llamaindex/#with-simple-directory-reader","title":"With Simple Directory Reader\u00b6","text":""},{"location":"examples/run_md/","title":"Run md","text":"In\u00a0[\u00a0]: Copied! <pre>import json\nimport logging\nimport os\nfrom pathlib import Path\n</pre> import json import logging import os from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import yaml\n</pre> import yaml In\u00a0[\u00a0]: Copied! <pre>from docling.backend.md_backend import MarkdownDocumentBackend\nfrom docling.datamodel.base_models import InputFormat\nfrom docling.datamodel.document import InputDocument\n</pre> from docling.backend.md_backend import MarkdownDocumentBackend from docling.datamodel.base_models import InputFormat from docling.datamodel.document import InputDocument In\u00a0[\u00a0]: Copied! <pre>_log = logging.getLogger(__name__)\n</pre> _log = logging.getLogger(__name__) In\u00a0[\u00a0]: Copied! <pre>def main():\n    input_paths = [Path(\"README.md\")]\n\n    for path in input_paths:\n        in_doc = InputDocument(\n            path_or_stream=path,\n            format=InputFormat.PDF,\n            backend=MarkdownDocumentBackend,\n        )\n        mdb = MarkdownDocumentBackend(in_doc=in_doc, path_or_stream=path)\n        document = mdb.convert()\n\n        out_path = Path(\"scratch\")\n        print(\n            f\"Document {path} converted.\" f\"\\nSaved markdown output to: {str(out_path)}\"\n        )\n\n        # Export Docling document format to markdowndoc:\n        fn = os.path.basename(path)\n\n        with (out_path / f\"{fn}.md\").open(\"w\") as fp:\n            fp.write(document.export_to_markdown())\n\n        with (out_path / f\"{fn}.json\").open(\"w\") as fp:\n            fp.write(json.dumps(document.export_to_dict()))\n\n        with (out_path / f\"{fn}.yaml\").open(\"w\") as fp:\n            fp.write(yaml.safe_dump(document.export_to_dict()))\n</pre> def main():     input_paths = [Path(\"README.md\")]      for path in input_paths:         in_doc = InputDocument(             path_or_stream=path,             format=InputFormat.PDF,             backend=MarkdownDocumentBackend,         )         mdb = MarkdownDocumentBackend(in_doc=in_doc, path_or_stream=path)         document = mdb.convert()          out_path = Path(\"scratch\")         print(             f\"Document {path} converted.\" f\"\\nSaved markdown output to: {str(out_path)}\"         )          # Export Docling document format to markdowndoc:         fn = os.path.basename(path)          with (out_path / f\"{fn}.md\").open(\"w\") as fp:             fp.write(document.export_to_markdown())          with (out_path / f\"{fn}.json\").open(\"w\") as fp:             fp.write(json.dumps(document.export_to_dict()))          with (out_path / f\"{fn}.yaml\").open(\"w\") as fp:             fp.write(yaml.safe_dump(document.export_to_dict())) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"},{"location":"examples/run_with_formats/","title":"Multi-format conversion","text":"In\u00a0[\u00a0]: Copied! <pre>import json\nimport logging\nfrom pathlib import Path\n</pre> import json import logging from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import yaml\n</pre> import yaml In\u00a0[\u00a0]: Copied! <pre>from docling.backend.pypdfium2_backend import PyPdfiumDocumentBackend\nfrom docling.datamodel.base_models import InputFormat\nfrom docling.document_converter import (\n    DocumentConverter,\n    PdfFormatOption,\n    WordFormatOption,\n)\nfrom docling.pipeline.simple_pipeline import SimplePipeline\nfrom docling.pipeline.standard_pdf_pipeline import StandardPdfPipeline\n</pre> from docling.backend.pypdfium2_backend import PyPdfiumDocumentBackend from docling.datamodel.base_models import InputFormat from docling.document_converter import (     DocumentConverter,     PdfFormatOption,     WordFormatOption, ) from docling.pipeline.simple_pipeline import SimplePipeline from docling.pipeline.standard_pdf_pipeline import StandardPdfPipeline In\u00a0[\u00a0]: Copied! <pre>_log = logging.getLogger(__name__)\n</pre> _log = logging.getLogger(__name__) In\u00a0[\u00a0]: Copied! <pre>def main():\n    input_paths = [\n        Path(\"README.md\"),\n        Path(\"tests/data/html/wiki_duck.html\"),\n        Path(\"tests/data/docx/word_sample.docx\"),\n        Path(\"tests/data/docx/lorem_ipsum.docx\"),\n        Path(\"tests/data/pptx/powerpoint_sample.pptx\"),\n        Path(\"tests/data/2305.03393v1-pg9-img.png\"),\n        Path(\"tests/data/2206.01062.pdf\"),\n        Path(\"tests/data/test_01.asciidoc\"),\n        Path(\"tests/data/test_01.asciidoc\"),\n    ]\n\n    ## for defaults use:\n    # doc_converter = DocumentConverter()\n\n    ## to customize use:\n\n    doc_converter = (\n        DocumentConverter(  # all of the below is optional, has internal defaults.\n            allowed_formats=[\n                InputFormat.PDF,\n                InputFormat.IMAGE,\n                InputFormat.DOCX,\n                InputFormat.HTML,\n                InputFormat.PPTX,\n                InputFormat.ASCIIDOC,\n                InputFormat.MD,\n            ],  # whitelist formats, non-matching files are ignored.\n            format_options={\n                InputFormat.PDF: PdfFormatOption(\n                    pipeline_cls=StandardPdfPipeline, backend=PyPdfiumDocumentBackend\n                ),\n                InputFormat.DOCX: WordFormatOption(\n                    pipeline_cls=SimplePipeline  # , backend=MsWordDocumentBackend\n                ),\n            },\n        )\n    )\n\n    conv_results = doc_converter.convert_all(input_paths)\n\n    for res in conv_results:\n        out_path = Path(\"scratch\")\n        print(\n            f\"Document {res.input.file.name} converted.\"\n            f\"\\nSaved markdown output to: {str(out_path)}\"\n        )\n        _log.debug(res.document._export_to_indented_text(max_text_len=16))\n        # Export Docling document format to markdowndoc:\n        with (out_path / f\"{res.input.file.stem}.md\").open(\"w\") as fp:\n            fp.write(res.document.export_to_markdown())\n\n        with (out_path / f\"{res.input.file.stem}.json\").open(\"w\") as fp:\n            fp.write(json.dumps(res.document.export_to_dict()))\n\n        with (out_path / f\"{res.input.file.stem}.yaml\").open(\"w\") as fp:\n            fp.write(yaml.safe_dump(res.document.export_to_dict()))\n</pre> def main():     input_paths = [         Path(\"README.md\"),         Path(\"tests/data/html/wiki_duck.html\"),         Path(\"tests/data/docx/word_sample.docx\"),         Path(\"tests/data/docx/lorem_ipsum.docx\"),         Path(\"tests/data/pptx/powerpoint_sample.pptx\"),         Path(\"tests/data/2305.03393v1-pg9-img.png\"),         Path(\"tests/data/2206.01062.pdf\"),         Path(\"tests/data/test_01.asciidoc\"),         Path(\"tests/data/test_01.asciidoc\"),     ]      ## for defaults use:     # doc_converter = DocumentConverter()      ## to customize use:      doc_converter = (         DocumentConverter(  # all of the below is optional, has internal defaults.             allowed_formats=[                 InputFormat.PDF,                 InputFormat.IMAGE,                 InputFormat.DOCX,                 InputFormat.HTML,                 InputFormat.PPTX,                 InputFormat.ASCIIDOC,                 InputFormat.MD,             ],  # whitelist formats, non-matching files are ignored.             format_options={                 InputFormat.PDF: PdfFormatOption(                     pipeline_cls=StandardPdfPipeline, backend=PyPdfiumDocumentBackend                 ),                 InputFormat.DOCX: WordFormatOption(                     pipeline_cls=SimplePipeline  # , backend=MsWordDocumentBackend                 ),             },         )     )      conv_results = doc_converter.convert_all(input_paths)      for res in conv_results:         out_path = Path(\"scratch\")         print(             f\"Document {res.input.file.name} converted.\"             f\"\\nSaved markdown output to: {str(out_path)}\"         )         _log.debug(res.document._export_to_indented_text(max_text_len=16))         # Export Docling document format to markdowndoc:         with (out_path / f\"{res.input.file.stem}.md\").open(\"w\") as fp:             fp.write(res.document.export_to_markdown())          with (out_path / f\"{res.input.file.stem}.json\").open(\"w\") as fp:             fp.write(json.dumps(res.document.export_to_dict()))          with (out_path / f\"{res.input.file.stem}.yaml\").open(\"w\") as fp:             fp.write(yaml.safe_dump(res.document.export_to_dict())) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"},{"location":"integrations/","title":"Integrations","text":"<p>Use the navigation on the left to browse through Docling integrations with popular frameworks and tools.</p>"},{"location":"integrations/data_prep_kit/","title":"Data Prep Kit","text":""},{"location":"integrations/data_prep_kit/#get-started","title":"Get started","text":"<p>Docling is used by the Data Prep Kit [\u2197] open-source toolkit for preparing unstructured data for LLM application development ranging from laptop scale to datacenter scale.</p> <p>Below you find the Data Prep Kit modules powered by Docling.</p>"},{"location":"integrations/data_prep_kit/#pdf-ingestion-to-parquet","title":"PDF ingestion to Parquet","text":"<ul> <li>\ud83d\udcbb GitHub [\u2197]</li> <li>\ud83d\udcd6 API docs [\u2197]</li> </ul>"},{"location":"integrations/data_prep_kit/#document-chunking","title":"Document chunking","text":"<ul> <li>\ud83d\udcbb GitHub [\u2197]</li> <li>\ud83d\udcd6 API docs [\u2197]</li> </ul>"},{"location":"integrations/llamaindex/","title":"LlamaIndex \ud83e\udd99","text":""},{"location":"integrations/llamaindex/#get-started","title":"Get started","text":"<p>Docling is available as an official LlamaIndex [\u2197] extension.</p> <p>To get started, check out the step-by-step guide in LlamaIndex [\u2197].</p>"},{"location":"integrations/llamaindex/#components","title":"Components","text":""},{"location":"integrations/llamaindex/#docling-reader","title":"Docling Reader","text":"<p>Reads document files and uses Docling to populate LlamaIndex <code>Document</code> objects \u2014 either serializing Docling's data model (losslessly, e.g. as JSON) or exporting to a simplified format (lossily, e.g. as Markdown).</p> <ul> <li>\ud83d\udcbb GitHub [\u2197]</li> <li>\ud83d\udcd6 API docs [\u2197]</li> <li>\ud83d\udce6 PyPI [\u2197]</li> <li>\ud83e\udd99 LlamaHub [\u2197]</li> </ul>"},{"location":"integrations/llamaindex/#docling-node-parser","title":"Docling Node Parser","text":"<p>Reads LlamaIndex <code>Document</code> objects populated in Docling's format by Docling Reader and, using its knowledge of the Docling format, parses them to LlamaIndex <code>Node</code> objects for downstream usage in LlamaIndex applications, e.g. as chunks for embedding.</p> <ul> <li>\ud83d\udcbb GitHub [\u2197]</li> <li>\ud83d\udcd6 API docs [\u2197]</li> <li>\ud83d\udce6 PyPI [\u2197]</li> <li>\ud83e\udd99 LlamaHub [\u2197]</li> </ul>"}]}